# Pointers
A pointer is a variable that stores the address of another variable.

Declaring pointers
```cpp
int * p_number {}; // can only store address of a variable of type int
// storing other var type address gives error.

double * fractional_num{}; 
// can only store an address of a variable of type double

// Explicitly inittialize to nullptr
int * p_number1{nullptr};
int * fractional_num (nullptr);
// nullptr means the pointer is not pointing towards any address
// It does not represent any address yet
```

**NOTE:** All pointer variables are of the same size.

Position of `*` symbol doesnn't matter

```cpp
int* a{nullptr};
int * b{nullptr};
int *c{nullptr};
```

## Assigning data to pointer variable
```cpp
int int_var{43};
int *p_int{&int_var}

// YOu can change the address stored in a pointer any time
```

**NOTE**:Pointer only stores the type for which it was declared
Size of a pointer is `8 bytes`.

## Pointer to character
```cpp
char *p_char_var {nullptr};
char char_var {'A'};

p_char_var = &char_var;
```

**Initialize with a string literal**
```cpp
//Pointer to char can also do something special.
// YOu can initialize with a string literal: C-string.
char * p_message {"Hello World!"};

```cpp
char * p_message {"Hello World"}

//Printing out
// What do we get when we print this out with std::cout

std::cout << "The message is : " << p_message << std::endl;

//what dp we get when we deference the pointer
std::cout << "the value stored at p_message is : " << * p_message << std::endl;
```

**NOTE :** The string is made up of const char. Trying to modify any of them will result in a disaster.
```cpp
// Dont use this line of code as this may cause error DUe to above reason
* p_message = 'B'; // We want the message to say Bello World
```

Can modify the Pure array initialized with string literal
```cpp
char message2[] {"Hello World"};
message2[0] = 'T';

std::cout << "message2 : " << message2 << std::endl;
```

# Things not to do while initializing pointers
```cpp
//Writing  into uninitialized pointer through deference
int * p_number2; //contains junk address : could be anything 
*p_number2  = 55; // Writing into junk address : BAD!
```

```cpp
//int *p_number3(nullptr); //also works

int * p_number3{} //Initialized with pointer equivalent of zero : nullptr
// A pointer pointing nowhere
// *p_number = 33
// Writing into a pointer pointing nowhere : BAD CRASH 
```
## Program Memory Map

**Virtual Memory:** 
* Virtual memory is a technique where the OS gives each process the illusion of having a large, continuous block of memory, even if the computer’s physical RAM is smaller.
* A trick that tools program into thinking it is the only program running on your OS, and all memory resources.
* Each program is abstracted into a process, and each process has access to the memory range 0 - 2$^N$-1 where N is 32 on 32 bit system and 64 on 64 bit system.
  
The entire program is not loaded in real memory by the CPU and MMU. Only parts that are about to be executed are loaded. Making effective use of real memory, a valuable and lacking resource.

**Memory Map:** The memory map is a substracted format defined by the OS. All program written for that OS must conform to it. It is usually divided into some sections.

**Program Memory Map**
```
High Addresses
+-------------------+
| Command-line args |  (provided by OS)
| Environment vars  |
+-------------------+
|       Stack       |  (local vars, function calls)
|    ↓ grows down   |
+-------------------+
|       Heap        |  (dynamic memory: new/malloc)
|    ↑ grows up     |
+-------------------+
|    BSS Segment    |  (uninitialized global & static vars)
+-------------------+
|   Data Segment    |  (initialized global & static vars)
+-------------------+
|   Text Segment    |  (program code, literals, const data)
+-------------------+
Low Addresses

```
**Stack:** 
* Stores local variables, functions parameters, return address.
* Each function call pushes a stack frame.


**Heap:**
* For dynamic memory allocation (new, malloc).
* Grows upwards during execution
* Additional memory that can be queried for at run time


## Dynamic Memory Allocations
| Stack | Heap |
|-------|------|
|Memory is finite | Memory is finite |
|The developer isn't in full control of the memory lifetime. | The developers is in full control of when memory is allocated and when it's released. |
|Lifetime is controlled by the scope mechanism | lifetime is controlled explicitly through new and delete operations.|

**Dynamic alllocation** == creating variables / arrays at runtime (on the heap) using `new` and freeing them with `delete`.

```cpp
int *p = new int; //memory allocated on heap
*p = 10;
cout << *p;
delete p;
```

Dynamic Allocation is used when:
* Data size is not known in advance 
* You need flexible memory management
* YOu need data structures that grow / shrink at runtime.

```cpp
//BAD
//Writing into uninitialized pointer through dereference
/*
int *p_number2; // Contains junk address : could be anything
std::cout << "Writting in the 55" << std::endl;
*p_number2 = 55; // Writing into junk address : BAD!
std::cout << std::endl;
std::cout << "Writing into uninitialized pointer through dereference" << std::endl;
std::cout << "p_number2 : " << p_number2 << std::endl; // Reading from junk address.
std::cout << "Dereferencing bad memory" << std::endl;
std::cout << "*p_number2 : " << *p_number2 << std::endl;
*/
```

```cpp
//Initializing pointer to null
    /*
	//int *p_number3{nullptr}; // Also works
	int * p_number3 {}; // Initialized with pointer equivalent of zero : nullptr
						// A pointer pointing nowhere
    std::cout << "Writting into nullptr memory" << std::endl;
	//*p_number3 = 33; // Writting into a pointer pointing nowhere : BAD, CRASH
    std::cout << "Done writting" << std::endl;
	
	std::cout << std::endl;
	std::cout << "Reading and writting through nullptr : " << std::endl;
	//std::cout << "p_number3 : " << p_number3 << std::endl;
	//std::cout << "*p_number3 : " << *p_number3 << std::endl;// Reading from nullptr
															// BAD, CRASH.
                                                            */
```

```cpp
//Dynamic heap memory
int * p_num{nullptr};
p_num = new int;

//writing into a dynamically allocated memory
*p_num = 77;

//return memory to OS or deallocate memory
delete p_num;
p_num = nullptr;
```

It is also possible to declare in a single line
```cpp
int *p_numbers{new int (22)}; //Use direct initialization
int *p_number {new int {23}}; // use uniform initialization
```

**Note**: alaways remember to release the memory.

## Dangling pointers
A pointer that doesn't point to valid memory address. Trying to derefernce and use a dangling pointer will result in undefined behaviour.

How to avoid dangling pointers:
1. Uninitialized pointers:
```cpp
int * p_number;
std::cout << *p_number; // undefined (garbage or crash)
```
pointer not initialized, points to random memory.
* Solution:
Initialize pointers immediately
```cpp
int *p_num {nullptr};
int * p_num {new int(87)};
if (p_num != nullptr) std :: cout << *p_num;
```

2. **Deleted Pointer:** 
```cpp
int * p_num {new int{67}};
delete p_num;
std::cout << p_num;
```

Solution:
```cpp
delete p_num;
p_num = nullptr;
```

3. **Multiple pointers to same memory :**
```cpp
int * p_num1 {new int 83};
int * p_num2 {p_num1};
delete p_num1;
std::cout << * p_num2 //dangling pointer
```
	Why this happens ?
	* After `delete p_num1` the heap memory (value 83) is returned to the OS.
	* `p_num2` still holds the old address, but that memory is no longer valid.
	* Dereferencing '*p_num2` -> segmentation fault or garbage output.

Solution:
```cpp
//Master-Slave Pointer ownership
int *p_number8 {new int{382}};  // master
int *p_number9 {p_number8};     // slave

delete p_number8;  
p_number8 = nullptr;
if(p_number8 == nullptr) std::cerr << "WARNING: invalid pointer";
//safety guidline
// checks whether master pointer is valid or not
```

## When `new` fails
Simulation memory allocation failure
```cpp
    int * data = new int[10000000000000000]; // 

    for(size_t i{0} ; i < 10000000 ; ++i){
        int * data = new int[100000000];
    }
```

The exeception mechanism (try & catch):
```cpp
for(size_t i{0} ; i < 100 ; ++i){
        try{
            int * data = new int[1000000000];
        }catch(std::exception& ex){
            std::cout << "  Something went wrong : " << ex.what() << std::endl;
        }
    }
// here ex is the exception variable and ex.what() tells what exception happened
```

`std::nothrow`:
```cpp
    for(size_t i{0} ; i < 100 ; ++i){
   
        int * data = new(std::nothrow) int[1000000000];

        if(data!=nullptr){
            std::cout << "Data allocated" << std::endl;
        }else{
            std::cout << "Data allocation failed" << std::endl;
        }
       
    }
```

## Null pointer safety
Make sure you are working with pointers containing valid memory address.
* Null pointer checker

```cpp
if(!(p_number==nullptr)){
        std::cout << "p_number points to a VALID address : "<< p_number << std::endl;
        std::cout << "*p_number : " << *p_number << std::endl;
    }else{
        std::cout << "p_number points to an INVALID address." << std::endl;
    }
```

```cpp
 if(p_number){
        std::cout << "p_number points to a VALID address : "<< p_number << std::endl;
        std::cout << "*p_number : " << *p_number << std::endl;
    }else{
        std::cout << "p_number points to an INVALID address." << std::endl;
    }
```

```cpp
 delete p_number;
    nullptr;

    //It is OK call delete on a nullptr
	//Calling delete on a nullptr is OK
    int *p_number1 {};
    
    delete p_number1;	// This won't cause any problem
						//if p_number1 contains nullptr

```

## Memory Leaks
When we lose access to memory that is dynamuically allocated.

* situations where wwe can have memory leak
```cpp
int *p_number {new int{67}}; // Points to some address, let's call that address1

//Should delete and reset here 

int number{55}; // stack variable

p_number = &number; // Now p_number points to address2 , but address1 is still in use by 
					// our program. But our program has lost access to that memory location.
					//Memory has been leaked.
```
```cpp
//Double allocation 

int *p_number1 {new int{55}};

//Use the pointer

//Should delete and reset here.

p_number1 = new int{44}; // memory with int{55} leaked.

delete p_number1;
p_number1 = nullptr;

```

```cpp
//Nested scopes with dynamically allocated memory
{
	int *p_number2 {new int{57}};

	//Use the dynamic memory

}
//Memory with int{57} leaked.
```

## Dynamic Arrays
Arrays allocated on the hheap with the new operator. Can also use the std::nothrow version of new.

Array dynamic allocation
```cpp
const size_t size{10};

//Different ways you can declare an array
//dynamically and how they are initialized

double *p_salaries { new double[size]}; // salaries array will
														//contain garbage  values
int *p_students { new(std::nothrow) int[size]{} }; // All values initialized to 0 

double *p_scores { new(std::nothrow) double[size]{1,2,3,4,5}}; // Allocating memory space
																// for an array  of size double
																//vars. First 5 will be initialized
																//with 1,2,3,4,5, and the 
																//rest will be 0's.
```
Operations on dynamic array
```cpp
//nullptr check and use the allocated array
if(p_scores){
	std::cout << "size of scores (it's a regular pointer) : " << sizeof(p_scores) << std::endl;
	std::cout << "Successfully allocated memory for scores."<< std::endl;
	
	//Print out elements. Can use regular array access notation, or pointer arithmetic
	for( size_t i{}; i < size ; ++i){
		std::cout << "value : " << p_scores[i] << " : " << *(p_scores + i) << std::endl; 
	}
}
```

delete the dynamically allocated memory
```cpp
delete [] p_salaries;
p_salaries = nullptr;

delete [] p_students;
p_students = nullptr;

delete [] p_scores;
p_scores = nullptr;


**Static vs Dynamic arrays**
| Feature               | Static Array   | Dynamic Array                 |
| --------------------- | -------------- | ----------------------------- |
| **Size decided**      | Compile time   | Runtime                       |
| **Storage**           | Stack          | Heap                          |
| **Resizable?**        | ❌ No           | ✅ Yes (with reallocation)     |
| **Memory Management** | Automatic      | Manual (`delete[]`)           |
| **Speed**             | Faster (stack) | Slightly slower (heap access) |

