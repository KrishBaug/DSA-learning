# Pointers
A pointer is a variable that stores the address of another variable.

Declaring pointers
```cpp
int * p_number {}; // can only store address of a variable of type int
// storing other var type address gives error.

double * fractional_num{}; 
// can only store an address of a variable of type double

// Explicitly inittialize to nullptr
int * p_number1{nullptr};
int * fractional_num (nullptr);
// nullptr means the pointer is not pointing towards any address
// It does not represent any address yet
```

**NOTE:** All pointer variables are of the same size.

Position of `*` symbol doesnn't matter

```cpp
int* a{nullptr};
int * b{nullptr};
int *c{nullptr};
```

## Assigning data to pointer variable
```cpp
int int_var{43};
int *p_int{&int_var}

// YOu can change the address stored in a pointer any time
```

**NOTE**:Pointer only stores the type for which it was declared
Size of a pointer is `8 bytes`.

## Pointer to character
```cpp
char *p_char_var {nullptr};
char char_var {'A'};

p_char_var = &char_var;
```

**Initialize with a string literal**
```cpp
//Pointer to char can also do something special.
// YOu can initialize with a string literal: C-string.
char * p_message {"Hello World!"};

```cpp
char * p_message {"Hello World"}

//Printing out
// What do we get when we print this out with std::cout

std::cout << "The message is : " << p_message << std::endl;

//what dp we get when we deference the pointer
std::cout << "the value stored at p_message is : " << * p_message << std::endl;
```

**NOTE :** The string is made up of const char. Trying to modify any of them will result in a disaster.
```cpp
// Dont use this line of code as this may cause error DUe to above reason
* p_message = 'B'; // We want the message to say Bello World
```

Can modify the Pure array initialized with string literal
```cpp
char message2[] {"Hello World"};
message2[0] = 'T';

std::cout << "message2 : " << message2 << std::endl;
```

# Things not to do while initializing pointers
```cpp
//Writing  into uninitialized pointer through deference
int * p_number2; //contains junk address : could be anything 
*p_number2  = 55; // Writing into junk address : BAD!
```

```cpp
//int *p_number3(nullptr); //also works

int * p_number3{} //Initialized with pointer equivalent of zero : nullptr
// A pointer pointing nowhere
// *p_number = 33
// Writing into a pointer pointing nowhere : BAD CRASH 
```
## Program Memory Map

**Virtual Memory:** 
* Virtual memory is a technique where the OS gives each process the illusion of having a large, continuous block of memory, even if the computer’s physical RAM is smaller.
* A trick that tools program into thinking it is the only program running on your OS, and all memory resources.
* Each program is abstracted into a process, and each process has access to the memory range 0 - 2$^N$-1 where N is 32 on 32 bit system and 64 on 64 bit system.
  
The entire program is not loaded in real memory by the CPU and MMU. Only parts that are about to be executed are loaded. Making effective use of real memory, a valuable and lacking resource.

**Memory Map:** The memory map is a substracted format defined by the OS. All program written for that OS must conform to it. It is usually divided into some sections.

**Program Memory Map**

High Addresses
+-------------------+
| Command-line args |  (provided by OS)
| Environment vars  |
+-------------------+
|       Stack       |  (local vars, function calls)
|    ↓ grows down   |
+-------------------+
|       Heap        |  (dynamic memory: new/malloc)
|    ↑ grows up     |
+-------------------+
|    BSS Segment    |  (uninitialized global & static vars)
+-------------------+
|   Data Segment    |  (initialized global & static vars)
+-------------------+
|   Text Segment    |  (program code, literals, const data)
+-------------------+
Low Addresses


**Stack:** 
* Stores local variables, functions parameters, return address.
* Each function call pushes a stack frame.


**Heap:**
* For dynamic memory allocation (new, malloc).
* Grows upwards during execution
* Additional memory that can be queried for at run time
  
## Dynamic Memory Allocations
| Stack | Heap |
|-------|------|
|Memory is finite | Memory is finite |
|The developer isn't in full control of the memory lifetime. | The developers is in full control of when memory is allocated and when it's released. |
|Lifetime is controlled by the scope mechanism | lifetime is controlled explicitly through new and delete operations. |











