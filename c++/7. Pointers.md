# Pointers
A pointer is a variable that stores the address of another variable.

Declaring pointers
```cpp
int * p_number {}; // can only store address of a variable of type int
// storing other var type address gives error.

double * fractional_num{}; 
// can only store an address of a variable of type double

// Explicitly inittialize to nullptr
int * p_number1{nullptr};
int * fractional_num (nullptr);
// nullptr means the pointer is not pointing towards any address
// It does not represent any address yet
```

**NOTE:** All pointer variables are of the same size.

Position of `*` symbol doesnn't matter

```cpp
int* a{nullptr};
int * b{nullptr};
int *c{nullptr};
```

## Assigning data to pointer variable
```cpp
int int_var{43};
int *p_int{&int_var}

// YOu can change the address stored in a pointer any time
```

**NOTE**:Pointer only stores the type for which it was declared
Size of a pointer is `8 bytes`.

## Pointer to character
```cpp
char *p_char_var {nullptr};
char char_var {'A'};

p_char_var = &char_var;
```

**Initialize with a string literal**
```cpp
//Pointer to char can also do something special.
// YOu can initialize with a string literal: C-string.
char * p_message {"Hello World!"};

```cpp
char * p_message {"Hello World"}

//Printing out
// What do we get when we print this out with std::cout

std::cout << "The message is : " << p_message << std::endl;

//what dp we get when we deference the pointer
std::cout << "the value stored at p_message is : " << * p_message << std::endl;
```

**NOTE :** The string is made up of const char. Trying to modify any of them will result in a disaster.
```cpp
// Dont use this line of code as this may cause error DUe to above reason
* p_message = 'B'; // We want the message to say Bello World
```

Can modify the Pure array initialized with string literal
```cpp
char message2[] {"Hello World"};
message2[0] = 'T';

std::cout << "message2 : " << message2 << std::endl;
```

# Things not to do while initializing pointers
```cpp
//Writing  into uninitialized pointer through deference
int * p_number2; //contains junk address : could be anything 
*p_number2  = 55; // Writing into junk address : BAD!
```

```cpp
//int *p_number3(nullptr); //also works

int * p_number3{} //Initialized with pointer equivalent of zero : nullptr
// A pointer pointing nowhere
// *p_number = 33
// Writing into a pointer pointing nowhere : BAD CRASH 
```
## Program Memory Map

**Virtual Memory:** 
* Virtual memory is a technique where the OS gives each process the illusion of having a large, continuous block of memory, even if the computer’s physical RAM is smaller.
* A trick that tools program into thinking it is the only program running on your OS, and all memory resources.
* Each program is abstracted into a process, and each process has access to the memory range 0 - 2$^N$-1 where N is 32 on 32 bit system and 64 on 64 bit system.
  
The entire program is not loaded in real memory by the CPU and MMU. Only parts that are about to be executed are loaded. Making effective use of real memory, a valuable and lacking resource.

**Memory Map:** The memory map is a substracted format defined by the OS. All program written for that OS must conform to it. It is usually divided into some sections.

**Program Memory Map**

High Addresses
+-------------------+
| Command-line args |  (provided by OS)
| Environment vars  |
+-------------------+
|       Stack       |  (local vars, function calls)
|    ↓ grows down   |
+-------------------+
|       Heap        |  (dynamic memory: new/malloc)
|    ↑ grows up     |
+-------------------+
|    BSS Segment    |  (uninitialized global & static vars)
+-------------------+
|   Data Segment    |  (initialized global & static vars)
+-------------------+
|   Text Segment    |  (program code, literals, const data)
+-------------------+
Low Addresses


**Stack:** 
* Stores local variables, functions parameters, return address.
* Each function call pushes a stack frame.


**Heap:**
* For dynamic memory allocation (new, malloc).
* Grows upwards during execution
* Additional memory that can be queried for at run time


## Dynamic Memory Allocations
| Stack | Heap |
|-------|------|
|Memory is finite | Memory is finite |
|The developer isn't in full control of the memory lifetime. | The developers is in full control of when memory is allocated and when it's released. |
|Lifetime is controlled by the scope mechanism | lifetime is controlled explicitly through new and delete operations.|

**Dynamic alllocation** == creating variables / arrays at runtime (on the heap) using `new` and freeing them with `delete`.

```cpp
int *p = new int; //memory allocated on heap
*p = 10;
cout << *p;
delete p;
```

Dynamic Allocation is used when:
* Data size is not known in advance 
* You need flexible memory management
* YOu need data structures that grow / shrink at runtime.

```cpp
//BAD
//Writing into uninitialized pointer through dereference
/*
int *p_number2; // Contains junk address : could be anything
std::cout << "Writting in the 55" << std::endl;
*p_number2 = 55; // Writing into junk address : BAD!
std::cout << std::endl;
std::cout << "Writing into uninitialized pointer through dereference" << std::endl;
std::cout << "p_number2 : " << p_number2 << std::endl; // Reading from junk address.
std::cout << "Dereferencing bad memory" << std::endl;
std::cout << "*p_number2 : " << *p_number2 << std::endl;
*/
```

```cpp
//Initializing pointer to null
    /*
	//int *p_number3{nullptr}; // Also works
	int * p_number3 {}; // Initialized with pointer equivalent of zero : nullptr
						// A pointer pointing nowhere
    std::cout << "Writting into nullptr memory" << std::endl;
	//*p_number3 = 33; // Writting into a pointer pointing nowhere : BAD, CRASH
    std::cout << "Done writting" << std::endl;
	
	std::cout << std::endl;
	std::cout << "Reading and writting through nullptr : " << std::endl;
	//std::cout << "p_number3 : " << p_number3 << std::endl;
	//std::cout << "*p_number3 : " << *p_number3 << std::endl;// Reading from nullptr
															// BAD, CRASH.
                                                            */
```

```cpp
//Dynamic heap memory
int * p_num{nullptr};
p_num = new int;

//writing into a dynamically allocated memory
*p_num = 77;

//return memory to OS or deallocate memory
delete p_num;
p_num = nullptr;
```

It is also possible to declare in a single line
```cpp
int *p_numbers{new int (22)}; //Use direct initialization
int *p_number {new int {23}}; // use uniform initialization
```

**Note**: alaways remember to release the memory.

## Dangling pointers
How to avoid dangling pointers:
1. Uninitialized pointers:
```cpp
int * p_number;
std::cout << *p_number; // undefined (garbage or crash)
```
pointer not initialized, points to random memory.
* Solution:
Initialize pointers immediately
```cpp
int *p_num {nullptr};
int * p_num {new int(87)};
if (p_num != nullptr) std :: cout << *p_num;
```

2. **Deleted Pointer:** 
```cpp
int * p_num {new int{67}};
delete p_num;
std::cout << p_num;
```

Solution:
```cpp
delete p_num;
p_num = nullptr;
```

3. **Multiple pointers to same memory :**
```cpp
int * p_num1 {new int 83};
int * p_num2 {p_num1};
delete p_num1;
std::cout << * p_num2 //dangling pointer
```

Solution:
```cpp
//Slave Pointer ownership
int * []
```






