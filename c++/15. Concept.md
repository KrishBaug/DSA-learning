# Concepts 
A mechanism to place constraints on your template type parameters.

* concept is a compile type predicate that checks whether a type meets certain requirements.

```cpp
#include <concepts>
#include <iostream>
using namespace std;

template<std::integral T>
T add(T a, T b) {
    return a + b;
}

int main() {
    cout << add(5, 3) << endl; // OK
    // cout << add(5.5, 2.2); // Error: double not integral
}

```

| Concept                         | Description                        | Example                                           |
| ------------------------------- | ---------------------------------- | ------------------------------------------------- |
| **std::integral**               | Matches all integer types          | `template<std::integral T> T add(T a, T b);`      |
| **std::floating\_point**        | Matches float, double, long double | `template<std::floating_point T> T sqrt(T x);`    |
| **std::signed\_integral**       | Matches signed integer types       | `int8_t, int, long`                               |
| **std::unsigned\_integral**     | Matches unsigned integer types     | `uint8_t, unsigned int`                           |
| **std::same\_as\<T,U>**         | Checks two types are the same      | `template<std::same_as<int> T> ...`               |
| **std::convertible\_to\<T,U>**  | T can convert to U                 | `template<std::convertible_to<int,double> T> ...` |
| **std::assignable\_from\<T,U>** | T can be assigned from U           | Useful in templates                               |


**Other Useful / specialized concepts**
| Concept                         | Notes / Use Case                                                      |
| ------------------------------- | --------------------------------------------------------------------- |
| **std::derived\_from<Base>**    | Type inherits from Base                                               |
| **std::derived\_from\<T, U>**   | T inherits from U                                                     |
| **std::invocable**              | Callable with given arguments (functions, lambdas)                    |
| **std::regular**                | Satisfies regular type requirements (copyable, default constructible) |
| **std::destructible**           | Type can be safely destroyed                                          |
| **std::default\_initializable** | Can be default constructed                                            |
| **std::equality\_comparable**   | Supports `==` and `!=`                                                |
| **std::totally\_ordered**       | Supports `<, <=, >, >=`                                               |
| **std::swappable**              | Can be swapped                                                        |
| **std::boolean\_testable**      | Can be used in `if`/`while` conditions                                |


## Custom Concept
A custom concept is a compile-time predicate that checks if a type satisfies certain requirements.

* **Syntax**
```cpp
template<typename T>
concept ConceptName = /* boolean expression involving T */;
```

**Example :**

```cpp
#include <concepts>
#include <iostream>
using namespace std;

// Custom concept
template<typename T>
concept PositiveIntegral = std::integral<T> && (requires(T x){ x > 0; });

template<PositiveIntegral T>
T square(T a) {
    return a * a;
}

int main() {
    cout << square(5) << endl; // OK
    // cout << square(5.5);   // Error: double not integral
}
```

## Require Statement for complex rules
```cpp
template<typename T>
concept Addable = requires(T a, T b) {
    { a + b } -> std::same_as<T>;  // T must support + and result type T
};

template<Addable T>
T add(T a, T b) {
    return a + b;
}

int main() {
    cout << add(3, 4) << endl;      // OK
    cout << add(3.5, 2.1) << endl;  // OK
    // cout << add(3, "hi");        // Error
}
```

The requires clause allows you to specify constraints on template parameters directly.
It can appear in two ways:

* Inline in template declaration

* As a requires expression (more flexible, can check multiple conditions)

**Basic Syntax :**
```cpp
#include <concepts>

template<typename T>
requires std::integral<T>  // constraint
T add(T a, T b) {
    return a + b;
}
// Here, add can only be instantiated with integral types.


```

**Using `requires` expression (Zoom In):
```cpp
template<typename T>
concept Addable = requires(T a, T b) {
    { a + b } -> std::same_as<T>;  // Checks T + T returns T
};

template<typename T>
requires Addable<T>  // Apply the concept
T sum(T a, T b) {
    return a + b;
}
```
* requires(T a, T b) { ... } → checks that expressions inside are valid for type T.

* Arrow -> → ensures the result type matches a certain type (std::same_as<T>).

* Multiple expressions can be checked inside {} separated by semicolons:
```cpp
template<typename T>

concept Arithmetic = requires(T a, T b) {
    { a + b } -> std::same_as<T>;
    { a - b } -> std::same_as<T>;
    { a * b } -> std::same_as<T>;
    { a / b } -> std::same_as<T>;
};
```

**Using `requires` clause after template Prameters**
```cpp
template<typename T>
T multiply(T a, T b) requires std::floating_point<T> {
    return a * b;
}
// leaner alternative to writing template<std::floating_point T>.
```


**Why custom conepts are used ?**
1. **Readable templates :** you can write `template<PositiveIntegeral T>` instead of verbose.
2. Better compile time errors -- if a type doesn't satisfy the concept, compiler shows a clear message.
3. **Reusable constraints :** define once, use everywhere.

## Logical Combinations of Concepts
1. And (&&) - all conditions must be true
```cpp
template<typename T>
concept PositiveIntegral = std::integral<T> && requires(T a){ a>0; };
```

2. OR(||) - either condition true
```cpp
template<typename T>
concept IntOrFloat = std::integral<T> || std::floating_point<T>;
```

3. NOT(!) - negotiate a concept
```cpp
template<typename T>
concept NotPointer = !std::is_pointer_v<T>;
```

4. With multiple comobos
```cpp
template<typename T>
concept Custom = (std::integral<T> || std::floating_point<T>) && !std::is_const_v<T>;
```

5. With `requires` expression:
```cpp
template<typename T>
concept AddableOrSub = requires(T a,T b){a+b;} || requires(T a,T b){a-b;};
```

## Using Concepts with auto in Functions

```cpp
// Without concepts → accepts any type (unsafe)
auto add(auto a, auto b) {
    return a + b;
}

// With concepts → restrict to integral types only
std::integral auto add(std::integral auto a, std::integral auto b) {
    return a + b;
}

- add(10, 20) ✅ works
- add(1.5, 2.5) ❌ compile-time error
```

**Using Concepts with auto in Variables**
```cpp
// Restrict variable to integral
std::integral auto x = add(10, 20);   // OK

// Restrict variable to floating point
std::floating_point auto y = 7.7;     // OK

// Example of error
std::floating_point auto z = add(10, 20); 
// ❌ ERROR: add() returns integral, not floating
```

**Why Use Concepts + auto?**
  * Improves type safety (invalid types rejected at compile time)
  * Makes template code easier to read and understand
  * Replaces older tricks like enable_if and SFINAE
  * Provides self-documenting code



**Syntax Summary :**
• For functions:
    * std::concept_name auto function(parameter);

• For variables:
    * std::concept_name auto variable = value;







