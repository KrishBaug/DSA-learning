# Inheritance 

**Concepts :**
* A derived class is class that inherits properties and behaviour of base class.
* Inherits data members and member functions (depending on access specifiers.)
* Allows code reuse and hierarchial relationships

**Syntax :**
```cpp
#include <iostream>
using namespace std;

// Base class
class Animal {
public:
    void eat() { cout << "Eating...\n"; }
};

// Derived class
class Dog : public Animal {  // public inheritance
public:
    void bark() { cout << "Barking...\n"; }
};

int main() {
    Dog d;
    d.eat();   // inherited from Animal
    d.bark();  // own function
}

```

* Public inheritance: base class public members → derived class public

* Base class functions can be called directly by derived objects

* Derived class can add new members or override existing ones


## Protected Members in Inheritance
**Concept :**
* Protect members of a class are:
  * Accessible inside the class
  * Accessible in derived classes
  * Not accessible outside the class (unlike public)
* Useful to allow derived classes to use members while hiding them from the outside world.

```cpp
#include <iostream>
using namespace std;

class Animal {
protected:
    string type;  // protected member
public:
    void setType(string t) { type = t; }
};

class Dog : public Animal {
public:
    void showType() { cout << "Animal type: " << type << endl; } // can access protected
};

int main() {
    Dog d;
    d.setType("Mammal");  // public function can access protected
    d.showType();
    // d.type = "Reptile"; // ❌ error: type is protected, cannot access directly
}
```

| Specifier     | Inside Class | Derived Class | Outside (objects) |
| ------------- | ------------ | ------------- | ----------------- |
| **Public**    | ✅ Yes        | ✅ Yes         | ✅ Yes             |
| **Protected** | ✅ Yes        | ✅ Yes         | ❌ No              |
| **Private**   | ✅ Yes        | ❌ No          | ❌ No              |

**Differences**

* Public: Everything is open → both derived classes and objects can access.

* Private: Locked → only the class itself can access. Derived classes and objects cannot.

* Protected: Middle ground → only derived classes can access, but outside objects can’t.

**Why/When to Use**

* ✅ Use public if you want everyone (objects + derived) to access.

* ✅ Use private if it’s strict internal logic/data (not even children should touch it).

* ✅ Use protected when:

  * You want derived classes to inherit and work with data

  * But you don’t want outside code to mess with it

  * Example: a base class framework where child classes customize internal details.

**Example to Compare**
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int pub = 1;
protected:
    int prot = 2;
private:
    int priv = 3;
};

class Derived : public Base {
public:
    void show() {
        cout << "Public: " << pub << endl;   // ✅ accessible
        cout << "Protected: " << prot << endl; // ✅ accessible
        // cout << "Private: " << priv; // ❌ not accessible
    }
};

int main() {
    Derived d;
    cout << d.pub << endl;    // ✅ accessible
    // cout << d.prot << endl; // ❌ not accessible (protected)
    // cout << d.priv << endl; // ❌ not accessible (private)
    d.show();
}
```
**Real Use Case**

* Suppose you’re writing a game engine:

* Entity has protected health → derived Player and Enemy can change it

* But outside code (like main) can’t directly modify health.

## Base Class Access Specifiers
When you inherit a class, the access specifier you choose (public, protected, private) changes how the base’s members are seen in the derived class.

**Code Demo :**
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int pub = 1;       // Public → "open to all"
protected:
    int prot = 2;      // Protected → "family only"
private:
    int priv = 3;      // Private → "locked inside Base"
};

// PUBLIC inheritance → keeps the same rules
class PublicDerived : public Base {
public:
    void show() {
        cout << "PublicDerived can access pub = " << pub << endl;
        cout << "PublicDerived can access prot = " << prot << endl;
        // cout << priv; ❌ Not accessible
    }
};

// PROTECTED inheritance → hides public from outside
class ProtectedDerived : protected Base {
public:
    void show() {
        cout << "ProtectedDerived can access pub = " << pub << endl;
        cout << "ProtectedDerived can access prot = " << prot << endl;
    }
};

// PRIVATE inheritance → hides everything from outside
class PrivateDerived : private Base {
public:
    void show() {
        cout << "PrivateDerived can access pub = " << pub << endl;
        cout << "PrivateDerived can access prot = " << prot << endl;
    }
};

int main() {
    PublicDerived pd;
    pd.show();
    cout << "Main can access pd.pub = " << pd.pub << endl;   // ✅ still public

    ProtectedDerived prd;
    prd.show();
    // cout << prd.pub; ❌ ERROR (public became protected)

    PrivateDerived prvd;
    prvd.show();
    // cout << prvd.pub; ❌ ERROR (public became private)

    return 0;
}
```

```output
PublicDerived can access pub = 1
PublicDerived can access prot = 2
Main can access pd.pub = 1
ProtectedDerived can access pub = 1
ProtectedDerived can access prot = 2
PrivateDerived can access pub = 1
PrivateDerived can access prot = 2
```

1. Public Inheritance (class D : public Base)

   * Public in Base → Public in Derived

   * Protected in Base → Protected in Derived

   * Private in Base → stays inaccessible

   * Subclasses of Derived: ✅ still see Base’s protected.

   * Outside world: ✅ can access Base’s public.

2. Protected Inheritance (class D : protected Base)

   * Public in Base → Protected in Derived

   * Protected in Base → Protected in Derived

   * Private in Base → stays inaccessible

   * Subclasses of Derived: ✅ can access Base’s protected.

   * Outside world: ❌ cannot access Base’s public anymore.

3. Private Inheritance (class D : private Base)

   * Public in Base → Private in Derived

   * Protected in Base → Private in Derived

   * Private in Base → stays inaccessible

   * Subclasses of Derived: ❌ cannot access Base’s members.

   * Outside world: ❌ cannot access Base’s public.

## Constructor in Inheritance
1. Base constructor always runs first, then derived constructor.

2. If base has default constructor → it runs automatically.

3. If base has parameterized constructor (no default) → derived must call it explicitly.

4. You can forward args from derived constructor → base constructor using initializer lis

**Example 1: base has default constructor**
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() { cout << "Base default constructor\n"; }
};

class Derived : public Base {
public:
    Derived() { cout << "Derived default constructor\n"; }
};

int main() {
    Derived d; 
}
// Output:
// Base default constructor
// Derived default constructor
```

**Example 2: Base has parameterized constructor only**
```cpp
class Base {
public:
    Base(int x) { cout << "Base constructor with x=" << x << "\n"; }
};

class Derived : public Base {
public:
    Derived(int y) : Base(y) {   // must call explicitly
        cout << "Derived constructor with y=" << y << "\n";
    }
};

int main() {
    Derived d(10);
}
// Output:
// Base constructor with x=10
// Derived constructor with y=10
```

**Example 3: Base has both (default + parametrized)**
```cpp
class Base {
public:
    Base() { cout << "Base default\n"; }
    Base(int x) { cout << "Base param: " << x << "\n"; }
};

class Derived : public Base {
public:
    Derived() { cout << "Derived default\n"; }
    Derived(int y) : Base(y) {  // explicitly call param
        cout << "Derived param: " << y << "\n";
    }
};

int main() {
    Derived d1;    // calls Base default + Derived default
    Derived d2(5); // calls Base param + Derived param
}
```
* Base default constructor runs automatically if not specified.

* If base doesn’t have default, you must call its param constructor.

* Use initializer list (: Base(args)) in derived constructor to control which base constructor runs.

## Custom Constructor in Inheritance
1. If you define your own constructor in Base, the compiler does NOT generate a default one.

2. Derived must explicitly call the correct Base constructor.

3. You can design multiple custom constructors in Base and pick which one Derived calls.

4. Constructors can pass values up the chain using initializer lists.

**Example 1: Only custom Constructor in Base**
```cpp
#include <iostream>
using namespace std;

class Base {
    int a;
public:
    Base(int x) { 
        a = x; 
        cout << "Base custom constructor: a=" << a << "\n"; 
    }
};

class Derived : public Base {
    int b;
public:
    // must call Base explicitly
    Derived(int x, int y) : Base(x), b(y) { 
        cout << "Derived custom constructor: b=" << b << "\n"; 
    }
};

int main() {
    Derived d(10, 20);
}
// Output:
// Base custom constructor: a=10
// Derived custom constructor: b=20
```
**Example 2: Multiple Custom Constructor in Base**
```cpp
class Base {
public:
    Base(int x) { cout << "Base param1: " << x << "\n"; }
    Base(int x, int y) { cout << "Base param2: " << x << "," << y << "\n"; }
};

class Derived : public Base {
public:
    Derived(int x) : Base(x) { cout << "Derived using Base(x)\n"; }
    Derived(int x, int y) : Base(x, y) { cout << "Derived using Base(x,y)\n"; }
};

int main() {
    Derived d1(5);    
    Derived d2(10, 20);
}
// Output:
// Base param1: 5
// Derived using Base(x)
// Base param2: 10,20
// Derived using Base(x,y)

```

**Example 3: Base Custom + Derived Custom Logic**
```cpp
class Base {
public:
    Base(string name) { cout << "Hello from Base, " << name << "\n"; }
};

class Derived : public Base {
public:
    Derived(string name, int age) : Base(name) { 
        cout << "Derived says age = " << age << "\n"; 
    }
};

int main() {
    Derived d("Krish", 17);
}
// Output:
// Hello from Base, Krish
// Derived says age = 17
```

## Resurrecting Members Back in Scope
* In private inheritance, base class public/protected members become private inside derived.

* But sometimes, you still want to make them usable again (publicly or protected).

* You can resurrect them using the `using` keyword.

**Syntax :**
```cpp
class Base {
public:
    void drive() { cout << "Driving...\n"; }
    void stop()  { cout << "Stopping...\n"; }
};

class Derived : private Base {
public:
    using Base::drive;  // ✅ resurrect drive() as public in Derived
    // stop() stays private
};

```
**How this Works :**
1. Without using `Base::drive;` →

   * `drive()` becomes private in Derived.

   * Can’t call `d.drive()` in `main()`.

2. With using `Base::drive;` →

   * You pull it back into Derived’s public interface.

   * Now `d.drive()` works.

**Example :**
```cpp
#include <iostream>
using namespace std;

class Car {
public:
    void drive() { cout << "Driving...\n"; }
    void stop()  { cout << "Stopping...\n"; }
};

class SportsCar : private Car {
public:
    // Resurrect only drive() into public scope
    using Car::drive;

    void turboBoost() { cout << "Turbo boost activated!\n"; }
};

int main() {
    SportsCar sc;
    
    sc.drive();       // ✅ works (resurrected to public)
    // sc.stop();     // ❌ still private (not resurrected)
    sc.turboBoost();  // ✅ normal SportsCar function
}
```

## Copy COnstructor with Inheritance

**When :**
* You create a new from an existing one.
* In inheritance, both Base and Derived parts must be copied.

**Why :**
* Compiler default = shallow copy (bitwise)
* Custom copy = ensures correct resource handling / deep copy.

**Rules**

1. Derived’s copy constructor must call Base’s copy constructor.

2. If you don’t write one → compiler generates default.

**Exampele : Without Custom Copy in Derived**
```cpp
#include <iostream>
using namespace std;

class Base {
    int a;
public:
    Base(int x = 0) : a(x) {}
    // copy constructor
    Base(const Base &b) { 
        a = b.a; 
        cout << "Base Copy Constructor\n"; 
    }
};

class Derived : public Base {
    int b;
public:
    Derived(int x = 0, int y = 0) : Base(x), b(y) {}
    // No custom copy -> compiler generates default
};

int main() {
    Derived d1(10, 20);
    Derived d2 = d1; // compiler creates a copy constructor

    // Base Copy Constructor is called automatically
}
// Output:
// Base Copy Constructor
```

**Example 2: Custom Copy Constructor in Derived**
```cpp
class Base {
    int a;
public:
    Base(int x = 0) : a(x) {}
    Base(const Base &b) { 
        a = b.a; 
        cout << "Base Copy Constructor\n"; 
    }
};

class Derived : public Base {
    int b;
public:
    Derived(int x = 0, int y = 0) : Base(x), b(y) {}

    // Custom copy constructor
    Derived(const Derived &d) : Base(d) {  // explicitly call Base copy
        b = d.b;
        cout << "Derived Copy Constructor\n";
    }
};

int main() {
    Derived d1(5, 15);
    Derived d2 = d1; // calls Derived copy constructor
}
// Output:
// Base Copy Constructor
// Derived Copy Constructor
```
* First `Base(d)` is called (copying Base part).

* Then Derived copies its own members.

**Example 3: What if we forget to call Base copy?**
```cpp
class Derived : public Base {
    int b;
public:
    Derived(const Derived &d) {   // ❌ forgot Base(d)
        b = d.b;
        cout << "Derived Copy Constructor (Base not copied!)\n";
    }
};
```

* Problem: Base part will be initialized with Base’s default constructor, not with a copy.
* That means data from Base is lost.

**4. Constructor copy paste with additional Parameters**
```cpp
#include <iostream>
using namespace std;

class Base {
    int a;
public:
    Base(int x=0): a(x) {}
    
    // Custom copy constructor with logging
    Base(const Base &b) {
        a = b.a; 
        cout << "Base copied with value: " << a << "\n";
    }
};

class Derived: public Base {
    int b;
public:
    Derived(int x=0,int y=0): Base(x), b(y) {}

    // Custom copy constructor with extra parameter
    Derived(const Derived &d, bool doubleCopy=false) 
        : Base(d)  // ✅ copy Base part
    {
        if(doubleCopy) 
            b = d.b * 2;   // modify while copying
        else 
            b = d.b;
        
        cout << "Derived copied with b = " << b << "\n";
    }
};

int main() {
    Derived d1(5,10);

    Derived d2(d1);           // normal copy
    Derived d3(d1, true);     // copy with modification (b doubled)
}
```

```output
Base copied with value: 5
Derived copied with b = 10
Base copied with value: 5
Derived copied with b = 20
```

## Inheriting Base Constructor
**When :**

* You want the Derived class to reuse all constructors of the Base class without rewriting.

**Why**

* Saves code repetition.

* Useful if Base has many constructors.

**How :**

* Use using `Base::Base;` inside Derived.

* This makes all Base’s constructors directly available in Derived.

✅ **Example**
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() { cout << "Base default\n"; }
    Base(int x) { cout << "Base with int: " << x << "\n"; }
};

class Derived : public Base {
public:
    using Base::Base; // inherit Base constructors
};

int main() {
    Derived d1;      // calls Base()
    Derived d2(42);  // calls Base(int)
}

Output
Base default
Base with int: 42
```
**Rules :**

* If you define your own Derived constructor, it doesn’t remove inherited ones.

* You can still add new constructors in Derived.

* Destructor is never inherited.

### Ways to Inherit Constructor
```cpp
class Derived : public Base {
public:
    using Base::Base;  // auto reuse
};
Derived d(10);  // directly calls Base(int)
```

* No custom message/code in Derived.

* Just reuses Base’s constructor exactly as it is.

2. Custom constructor with explicit call

```cpp
class Derived : public Base {
public:
    Derived(int y) : Base(y) {   // must call Base explicitly
        cout << "Derived constructor with y=" << y << "\n";
    }
};
Derived d(10);
```
* Calls Base(int) but also executes extra code in Derived.

* You control behavior after Base initialization.

**Difference :**
* using Base::Base; → reuse as-is, no extra logic.

* Derived(int y) : Base(y) → customize + still call Base.

**When to use? :**

* If you only need Base’s constructors → using.

* If Derived must do extra work during creation → write your own constructor with : Base(...).

## Destructor in Inheritance
**Order of Destruction :**

* Always reverse of construction.

* First the Derived destructor, then the Base destructor.

* Ensures base class cleans up last.

**Virtual Destructors :**

* Needed when you delete an object through a base class pointer.

* Without virtual, only Base’s destructor runs → resource leak.

* With virtual, both Base and Derived destructors run properly.

**Example 1: Normal Destructors (stack object)**
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    ~Base() {
        cout << "Base destructor\n";
    }
};

class Derived : public Base {
public:
    ~Derived() {
        cout << "Derived destructor\n";
    }
};

int main() {
    Derived d;  
}
// Output:
// Derived destructor
// Base destructor
```

**Example 2: Deleting via Base pointer (without virtual)**
```cpp
class Base {
public:
    ~Base() { cout << "Base destructor\n"; }
};

class Derived : public Base {
public:
    ~Derived() { cout << "Derived destructor\n"; }
};

int main() {
    Base* ptr = new Derived();
    delete ptr;  
}
// Output:
// Base destructor
```

Problem: Derived destructor skipped → memory/resource leak.

**Example 3: Using virtual**
```cpp
class Base {
public:
    virtual ~Base() { cout << "Base destructor\n"; }
};

class Derived : public Base {
public:
    ~Derived() { cout << "Derived destructor\n"; }
};

int main() {
    Base* ptr = new Derived();
    delete ptr;
}
// Output:
// Derived destructor
// Base destructor
```

Correct cleanup.

**When & Why**

* If polymorphism is involved (base pointer/reference) → always make base destructor virtual.

* If no polymorphism (stack objects, no base pointers) → non-virtual is fine.

## Reused Symbols in Inheritance
When Base and Derived have same name members (data or functions):

* Derived hides Base’s symbol (doesn’t overwrite, just hides it).

* To access Base’s version → use scope resolution `Base::`.

**When & Why :**

* Used when same names are reused across inheritance.

* Useful when Derived wants its own version, but sometimes accidental.

* Fix via scope resolution (Base::) or using Base::func; to unhide Base overloads.

1. **Data Hiding**
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int x = 10;   // Base version of x
};

class Derived : public Base {
public:
    int x = 20;   // Hides Base::x
};

int main() {
    Derived d;

    cout << "Derived x: " << d.x << "\n";        // 20 (Derived hides Base's x)
    cout << "Base x: " << d.Base::x << "\n";     // 10 (Explicitly access Base version)
}
```

Concept: Derived x hides Base x.

**2. Function Hiding**
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void show() {
        cout << "Base show()\n";
    }
};

class Derived : public Base {
public:
    void show() {    // Hides Base::show()
        cout << "Derived show()\n";
    }
};

int main() {
    Derived d;

    d.show();           // Calls Derived::show()
    d.Base::show();     // Calls Base::show()
}
```

Concept: Same-name function in Derived hides Base version.

3. **Overload Hiding**
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void print(int a) {
        cout << "Base print(int): " << a << "\n";
    }
};

class Derived : public Base {
public:
    void print(double a) {    // Hides Base::print(int)
        cout << "Derived print(double): " << a << "\n";
    }
};

int main() {
    Derived d;

    d.print(3.14);          // Calls Derived::print(double)
    // d.print(100);        // ❌ Error: Base::print(int) is hidden
    d.Base::print(100);     // ✅ Explicitly call Base version
}
```

Concept: When Derived defines a new overload, all overloads from Base are hidden.

### Very Important example
Example 1 – Same name (int x in both Base & Derived)
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int x = 10;
};

class Derived : public Base {
public:
    int x = 20;  // hides Base::x
};

int main() {
    Derived d;
    cout << "d.x = " << d.x << endl;          // Derived::x (20)
    cout << "Base::x = " << d.Base::x << endl; // Explicit access to Base::x (10)
    return 0;
}
```

Example 2 – Different names (int x in Base, int y in Derived)
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int x = 10;
};

class Derived : public Base {
public:
    int y = 20;
};

int main() {
    Derived d;
    cout << "d.x = " << d.x << endl; // Base::x (10) → accessible
    cout << "d.y = " << d.y << endl; // Derived::y (20)
    return 0;
}
```
* Example 3 – Accessing hidden Base member explicitly
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int x = 100;
};

class Derived : public Base {
public:
    int x = 200; // hides Base::x
};

int main() {
    Derived d;
    cout << "Derived x = " << d.x << endl;       // 200
    cout << "Base x (via scope) = " << d.Base::x << endl; // 100
    return 0;
}
```



