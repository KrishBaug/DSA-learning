# Lamda functions
* A mechanism to set up anonymous functions (without names). Once we have them set up, we can either give them names and call them, or we can even get them to do things directly.

* General Syntax
```cpp
[capture](parameters) -> return_type {
    // function body
};
```

```cpp
#include <iostream>
using namespace std;

int main() {
    auto add = [](int a, int b) {
        return a + b;
    };

    cout << add(5, 10) << endl;  // 15
}
```

**Call lambda function directly after definition**
```cpp
auto result = [](){
    std::cout << "Hello world" << std::endl;
}() // <--- Use round brackets at the end to directly call the functions
```

**Specify return type explicitly :**
```cpp
auto result = [](double a, double b)->double{
    return (a + b);
}(12.1, 5.7)
```

## Capture List
A capture list in a lambda defines which variables from the outside scope the lambda is allowed to use, and how (by value or by reference).

1. By Value([x]):
   * Copies `x` into the lambda.
   * The lambda works on its own copy.
```cpp
int a = 10;
auto f = [a]() { return a + 5; }; // captured by value
```

2. By Reference ([&x]):
   * Captures `x` by reference.
   * Changes inside lambda affect the original variable.

```cpp
int a = 10;
auto f = [&a]() { a += 5; }; // modifies original a
```

3. Capture All by Value ([=]):
   * Copies all the lambda from the surrounding scope into the lammbda.
```cpp
int a = 10, b = 20;
auto f = [=]() { return a + b; }; // both copied
```

4. Capture All by Reference([&]):
   * Takes all variables by refernce, so changes affect the outside. Any modifications inside affects original variables.
```cpp
int a = 10, b = 20;
auto f = [&]() { a += b; }; // modifies a
```

5. Mixed Captures:
   * Some by values, some by reference.
```cpp
int a = 10, b = 20;
auto f = [a, &b]() { return a + (++b); };
```

6. Move Captures:
   * this is when you want the lambda to take ownership of a resources (like a `std::unique_ptr` or a big `std::vector`) instead of copying or referencing it.
```cpp
auto ptr = std::make_unique<int>(5);
auto f = [p = std::move(ptr)]() { return *p; };
```






