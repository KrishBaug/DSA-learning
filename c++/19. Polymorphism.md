# Polymorphism 

1. What is Polymorphism :
   * Polymorphism = "many forms"
   * In C++, it means the same function name / operator can have different behaviors depending on context.
   * It's a key feature of Object-Oriented Programming (OOP).

2. Types of Polymorphism in C++:
   1. Compile-time polymorphism (static binding) :
      * Happens at compile time.
      * Achieved by:
        * Functions overloading -> same functions name, different parameters.
        * Operators overloading -> redefine operator (+, -, etc)
    2. Run-time polymorphism (dynamic binding) :
       * Virtual functions in inheritance.
       * Functions overriding in derived class.

**Example (both types)**
```cpp
#include <iostream>
using namespace std;

// Compile-time Polymorphism (Function Overloading)
class Math {
public:
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }
};

// Run-time Polymorphism (Virtual Function)
class Animal {
public:
    virtual void sound() {   // virtual → can be overridden
        cout << "Animal sound\n";
    }
};

class Dog : public Animal {
public:
    void sound() override {  // overrides base version
        cout << "Dog barks\n";
    }
};

int main() {
    // Compile-time polymorphism
    Math m;
    cout << m.add(2, 3) << endl;        // int version
    cout << m.add(2.5, 3.5) << endl;    // double version

    // Run-time polymorphism
    Animal* a;
    Dog d;
    a = &d;      // base pointer → derived object
    a->sound();  // calls Dog’s sound()

    return 0;
}
```

OUTPUT :
```output
5
6
Dog barks
```

## Static Binding With Inheritance
**What is Static Binding ?**
* Also called early binding.
* Function call is decided at compile time.
* Happens when no `virtual` keyword is used.
* The functions called depends on the type of the pointer / reference, not the actual object.

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void sound() {   // ❌ not virtual
        cout << "Animal sound\n";
    }
};

class Dog : public Animal {
public:
    void sound() {   // hides Animal's version
        cout << "Dog barks\n";
    }
};

int main() {
    Animal* a;   // base class pointer
    Dog d;

    a = &d;      // base pointer points to Dog object

    a->sound();  // Static binding -> Animal's version
    d.sound();   // Direct call -> Dog's version
}

```

OUTPUT :
```output
Animal sound
Dog barks
```

* `a->sound()`; → Base pointer → Animal’s function is called.

* `d.sound();` → Derived object → Dog’s function is called.

* Since no virtual is used, the compiler binds function calls at compile time → this is static binding.

## What is Dynamic Binding ?
* Also called late binding or runtime polymorphism.
* Functions call is derived at runtime based on the actual object.
* Achieved with the `virtual` keyword in base class.

**Example :**
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void sound() {   // ✅ virtual
        cout << "Animal sound\n";
    }
};

class Dog : public Animal {
public:
    void sound() override {  // override base version
        cout << "Dog barks\n";
    }
};

class Cat : public Animal {
public:
    void sound() override {
        cout << "Cat meows\n";
    }
};

int main() {
    Animal* a;   // base pointer

    Dog d;
    Cat c;

    a = &d;      // base pointer → Dog object
    a->sound();  // Runtime decision → Dog barks

    a = &c;      // base pointer → Cat object
    a->sound();  // Runtime decision → Cat meows
}
```

```output
Dog barks
Cat meows
```

* `virtual` in base → enables runtime decision.

* Base pointer/reference calls the derived version.

* Without `virtual` → base version would run (static binding).

* Internally uses a vtable (virtual table) to map function calls at runtime.

## Static vs Dynamic Binding

| Feature                    | Static Binding (Early)                                                                 | Dynamic Binding (Late)                                                                                |
| -------------------------- | -------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- |
| **Decision Time**          | At **compile time**                                                                    | At **runtime**                                                                                        |
| **Keyword Needed**         | None (default behavior)                                                                | `virtual` in base class                                                                               |
| **Function Call Based On** | Type of **pointer/reference**                                                          | Type of the **actual object**                                                                         |
| **Speed**                  | Faster (no extra lookup)                                                               | Slightly slower (uses vtable lookup)                                                                  |
| **Flexibility**            | Rigid (can’t change at runtime)                                                        | Flexible (decides at runtime)                                                                         |
| **Example Output**         | `Animal* a = new Dog(); a->sound(); → Animal`                                          | `Animal* a = new Dog(); a->sound(); → Dog`                                                            |
| **Main Use Case**          | When behavior is **fixed** and performance is key (e.g., math functions, utility code) | When behavior should **depend on object type** (e.g., GUI widgets, game characters, animals in a zoo) |

* Static binding → good for overloading, operators, utility code where speed matters and behavior is predictable.

* Dynamic binding → good for polymorphic hierarchies like shapes (circle, square), animals (dog, cat), UI components (button, slider) where behavior changes at runtime.

## Size of Polymorphic Objects & Object Slicing
* When a class has at least one virtual function, the compiler usually adds ahidden pointer called vptr (Virtual Table Pointer).
* This increase the size of the object (implementation-dependent, but usually by 4 or 8 bytes).

**Example :**
```cpp
#include <iostream>
using namespace std;

class A {
    int x;              // 4 bytes
    virtual void f() {} // adds vptr
};

class B {
    int x;              // 4 bytes
    void f() {}         // not virtual
};

int main() {
    cout << sizeof(A) << endl;
    cout << sizeof(B) << endl;
}
```

OUTPUT :
```cpp
16   // A (int + vptr + padding)
4    // B (just int)

```

**Object slicing :**
* Happens when a derived object is assigned to a base object (not pointer/reference).

* The extra data in derived class is “sliced off”, only base part is kept.

* Also kills polymorphism (virtual functions won’t behave dynamically anymore).

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void sound() { cout << "Animal sound\n"; }
};

class Dog : public Animal {
    int barkLevel = 5;
public:
    void sound() override { cout << "Dog barks\n"; }
};

int main() {
    Dog d;
    Animal a = d;  // slicing: Dog part lost
    a.sound();     // prints "Animal sound" (no polymorphism)
}
```

* Polymorphic objects are larger due to `vptr`.

* Object slicing happens when assigning derived → base by value. Always use pointers/references to preserve polymorphism.


## Polymorphic Objects Stored in Collections
* In C++, when we put derived objects inside a collections of base objects, only the base part is stored. THis is called object slicing.
* TO keep polymorphism, we should store pointers or refernces. (`vector<Base*>`,)(`vector<unique_ptr<Base>>`)

**Case 1: Store by value → ❌ slicing**
```cpp
#include <iostream>
#include <vector>
using namespace std;

class Animal {
public:
    virtual void sound() { cout << "Animal sound\n"; }
};

class Dog : public Animal {
public:
    void sound() override { cout << "Dog barks\n"; }
};

int main() {
    vector<Animal> animals;   // storing objects directly
    animals.push_back(Dog()); // Dog sliced into Animal

    for (auto &a : animals)
        a.sound();
}
```

OUTPUT :
```cpp
Animal sound
```

**Case 2: Store by pointer → ✅ works**
```cpp
#include <iostream>
#include <vector>
using namespace std;

class Animal {
public:
    virtual void sound() { cout << "Animal sound\n"; }
};

class Dog : public Animal {
public:
    void sound() override { cout << "Dog barks\n"; }
};

int main() {
    vector<Animal*> animals;   // store pointers
    animals.push_back(new Dog());

    for (auto a : animals)
        a->sound();
}
```

## `override` keyword in C++

* When a derived class provides a new definition for a virtual functions from the base class, it's called overiding.
* Using the `override` keyword makes the compiler check correctness
* If you mistype or mismatch parameters, the compiler will throw an error instead of silently creating a new functions.

**Example :**
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void sound() { cout << "Animal sound\n"; }
};

class Dog : public Animal {
public:
    void sound() override {   // override ensures this matches a base virtual function
        cout << "Dog barks\n";
    }
};

class Cat : public Animal {
public:
    void sounds() override {   // ❌ typo, compiler error!
        cout << "Cat meows\n";
    }
};

int main() {
    Animal* a = new Dog();
    a->sound();
}
```

```output
Dog barks
```

**Key Point :**
* Without `override`, the typo in `Cat::sounds()` would compile but not override -> bug!
* With `override`, compiler catches it.

`override` = safety net overriding virtual functions.  

## Overloading, Overriding & Hiding in C++

| Concept         | Meaning                                                                                                                                           | Binding               | Example Use Case                               |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------- | ---------------------------------------------- |
| **Overloading** | Same function name, **different parameter list** in the same scope.                                                                               | Compile-time (static) | `add(int, int)` vs `add(double, double)`       |
| **Overriding**  | Derived class **redefines a virtual function** of base class (same signature).                                                                    | Runtime (dynamic)     | `Animal::sound()` overridden in `Dog::sound()` |
| **Hiding**      | Derived class defines a function with the **same name** as base, but not marked `virtual`. It hides the base version (even if parameters differ). | Compile-time          | Avoid accidental use of base class function    |


**Example :**
```cpp
#include <iostream>
using namespace std;

// ---------- Overloading ----------
class Math {
public:
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; } // Overloaded
};

// ---------- Overriding ----------
class Animal {
public:
    virtual void sound() { cout << "Animal sound\n"; }
};

class Dog : public Animal {
public:
    void sound() override { cout << "Dog barks\n"; }
};

// ---------- Hiding ----------
class Base {
public:
    void show() { cout << "Base show\n"; }
};

class Derived : public Base {
public:
    void show(int x) { cout << "Derived show with " << x << "\n"; } // hides Base::show()
};

int main() {
    // Overloading
    Math m;
    cout << "Overloading: " << m.add(2, 3) << ", " << m.add(2.5, 3.5) << endl;

    // Overriding
    Animal* a = new Dog();
    cout << "Overriding: "; a->sound();

    // Hiding
    Derived d;
    cout << "Hiding: "; d.show(10);
    // d.show();  // ❌ error: Base::show() hidden
}
```

```output
Overloading: 5, 6
Overriding: Dog barks
Hiding: Derived show with 10
```

*  Overloading = Same name, different signature (compile-time).

* Overriding = Virtual function redefined (runtime).

* Hiding = Base function shadowed, not overridden.

# Inheritance & Polymorphism at Different Levels

When using inheritance, functions can be called at different levels:
* **Base class reference / pointer :** decides whether polymorphism works (via `virtual`).
* **Object of base vs arrived :** slicing may occur if stored directly as base object.
* **Overiddden vs. hidden vs. non-virtual:** determines binding (static vs dynamic)

| Case                        | Function Call From | Virtual? | Which Version Runs             |
| --------------------------- | ------------------ | -------- | ------------------------------ |
| Base pointer to Base obj    | Base               | Yes/No   | Base function                  |
| Base pointer to Derived obj | Derived            | Yes      | Derived function               |
| Base pointer to Derived obj | Derived            | No       | Base function (static binding) |
| Derived object directly     | Derived            | N/A      | Derived function               |

**Example :**
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void normalFunc() { cout << "Base normal function\n"; }
    virtual void virtualFunc() { cout << "Base virtual function\n"; }
};

class Derived : public Base {
public:
    void normalFunc() { cout << "Derived normal function\n"; }
    void virtualFunc() override { cout << "Derived virtual function\n"; }
};

int main() {
    Base b;
    Derived d;
    Base* ptr;   // base class pointer

    cout << "--- Base object ---\n";
    b.normalFunc();     // Base
    b.virtualFunc();    // Base

    cout << "\n--- Derived object ---\n";
    d.normalFunc();     // Derived
    d.virtualFunc();    // Derived

    cout << "\n--- Base pointer to Base object ---\n";
    ptr = &b;
    ptr->normalFunc();  // Base (static)
    ptr->virtualFunc(); // Base (dynamic but still base obj)

    cout << "\n--- Base pointer to Derived object ---\n";
    ptr = &d;
    ptr->normalFunc();  // Base (static binding)
    ptr->virtualFunc(); // Derived (dynamic binding)
}
```

```output
--- Base object ---
Base normal function
Base virtual function

--- Derived object ---
Derived normal function
Derived virtual function

--- Base pointer to Base object ---
Base normal function
Base virtual function

--- Base pointer to Derived object ---
Base normal function
Derived virtual function
```

* normalFunc() (non-virtual) always uses Base version if accessed through Base*.

* virtualFunc() (virtual) resolves at runtime → Derived version runs if Base* points to Derived.

## Polymorphism and Static Members in Inheritance
* Static members belong to the class itself, not to objects.
* They do not participate in polymorphism -> always resolved at compile time (static binding).
* Even if declared in base and re-declared in derived, they don't behave llike `virtual` functions.

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    static void show() {
        cout << "Base static function\n";
    }
};

class Derived : public Base {
public:
    static void show() {
        cout << "Derived static function\n";
    }
};

int main() {
    Base b;
    Derived d;
    Base* ptr = &d;

    cout << "--- Direct Calls ---\n";
    b.show();   // Base
    d.show();   // Derived

    cout << "\n--- Using Base pointer ---\n";
    ptr->show();  // Base (static binding, not polymorphic)

    cout << "\n--- Class name access ---\n";
    Base::show();    // Base
    Derived::show(); // Derived
}
```



