# Polymorphism 

1. What is Polymorphism :
   * Polymorphism = "many forms"
   * In C++, it means the same function name / operator can have different behaviors depending on context.
   * It's a key feature of Object-Oriented Programming (OOP).

2. Types of Polymorphism in C++:
   1. Compile-time polymorphism (static binding) :
      * Happens at compile time.
      * Achieved by:
        * Functions overloading -> same functions name, different parameters.
        * Operators overloading -> redefine operator (+, -, etc)
    2. Run-time polymorphism (dynamic binding) :
       * Virtual functions in inheritance.
       * Functions overriding in derived class.

**Example (both types)**
```cpp
#include <iostream>
using namespace std;

// Compile-time Polymorphism (Function Overloading)
class Math {
public:
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }
};

// Run-time Polymorphism (Virtual Function)
class Animal {
public:
    virtual void sound() {   // virtual → can be overridden
        cout << "Animal sound\n";
    }
};

class Dog : public Animal {
public:
    void sound() override {  // overrides base version
        cout << "Dog barks\n";
    }
};

int main() {
    // Compile-time polymorphism
    Math m;
    cout << m.add(2, 3) << endl;        // int version
    cout << m.add(2.5, 3.5) << endl;    // double version

    // Run-time polymorphism
    Animal* a;
    Dog d;
    a = &d;      // base pointer → derived object
    a->sound();  // calls Dog’s sound()

    return 0;
}
```

OUTPUT :
```output
5
6
Dog barks
```

## Static Binding With Inheritance
**What is Static Binding ?**
* Also called early binding.
* Function call is decided at compile time.
* Happens when no `virtual` keyword is used.
* The functions called depends on the type of the pointer / reference, not the actual object.

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void sound() {   // ❌ not virtual
        cout << "Animal sound\n";
    }
};

class Dog : public Animal {
public:
    void sound() {   // hides Animal's version
        cout << "Dog barks\n";
    }
};

int main() {
    Animal* a;   // base class pointer
    Dog d;

    a = &d;      // base pointer points to Dog object

    a->sound();  // Static binding -> Animal's version
    d.sound();   // Direct call -> Dog's version
}

```

OUTPUT :
```output
Animal sound
Dog barks
```

* `a->sound()`; → Base pointer → Animal’s function is called.

* `d.sound();` → Derived object → Dog’s function is called.

* Since no virtual is used, the compiler binds function calls at compile time → this is static binding.

## What is Dynamic Binding ?
* Also called late binding or runtime polymorphism.
* Functions call is derived at runtime based on the actual object.
* Achieved with the `virtual` keyword in base class.

**Example :**
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void sound() {   // ✅ virtual
        cout << "Animal sound\n";
    }
};

class Dog : public Animal {
public:
    void sound() override {  // override base version
        cout << "Dog barks\n";
    }
};

class Cat : public Animal {
public:
    void sound() override {
        cout << "Cat meows\n";
    }
};

int main() {
    Animal* a;   // base pointer

    Dog d;
    Cat c;

    a = &d;      // base pointer → Dog object
    a->sound();  // Runtime decision → Dog barks

    a = &c;      // base pointer → Cat object
    a->sound();  // Runtime decision → Cat meows
}
```

```output
Dog barks
Cat meows
```

* `virtual` in base → enables runtime decision.

* Base pointer/reference calls the derived version.

* Without `virtual` → base version would run (static binding).

* Internally uses a vtable (virtual table) to map function calls at runtime.

## Static vs Dynamic Binding

| Feature                    | Static Binding (Early)                                                                 | Dynamic Binding (Late)                                                                                |
| -------------------------- | -------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- |
| **Decision Time**          | At **compile time**                                                                    | At **runtime**                                                                                        |
| **Keyword Needed**         | None (default behavior)                                                                | `virtual` in base class                                                                               |
| **Function Call Based On** | Type of **pointer/reference**                                                          | Type of the **actual object**                                                                         |
| **Speed**                  | Faster (no extra lookup)                                                               | Slightly slower (uses vtable lookup)                                                                  |
| **Flexibility**            | Rigid (can’t change at runtime)                                                        | Flexible (decides at runtime)                                                                         |
| **Example Output**         | `Animal* a = new Dog(); a->sound(); → Animal`                                          | `Animal* a = new Dog(); a->sound(); → Dog`                                                            |
| **Main Use Case**          | When behavior is **fixed** and performance is key (e.g., math functions, utility code) | When behavior should **depend on object type** (e.g., GUI widgets, game characters, animals in a zoo) |

* Static binding → good for overloading, operators, utility code where speed matters and behavior is predictable.

* Dynamic binding → good for polymorphic hierarchies like shapes (circle, square), animals (dog, cat), UI components (button, slider) where behavior changes at runtime.

## Size of Polymorphic Objects & Object Slicing
* When a class has at least one virtual function, the compiler usually adds ahidden pointer called vptr (Virtual Table Pointer).
* This increase the size of the object (implementation-dependent, but usually by 4 or 8 bytes).

**Example :**
```cpp
#include <iostream>
using namespace std;

class A {
    int x;              // 4 bytes
    virtual void f() {} // adds vptr
};

class B {
    int x;              // 4 bytes
    void f() {}         // not virtual
};

int main() {
    cout << sizeof(A) << endl;
    cout << sizeof(B) << endl;
}
```

OUTPUT :
```cpp
16   // A (int + vptr + padding)
4    // B (just int)

```

**Object slicing :**
* Happens when a derived object is assigned to a base object (not pointer/reference).

* The extra data in derived class is “sliced off”, only base part is kept.

* Also kills polymorphism (virtual functions won’t behave dynamically anymore).

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void sound() { cout << "Animal sound\n"; }
};

class Dog : public Animal {
    int barkLevel = 5;
public:
    void sound() override { cout << "Dog barks\n"; }
};

int main() {
    Dog d;
    Animal a = d;  // slicing: Dog part lost
    a.sound();     // prints "Animal sound" (no polymorphism)
}
```

* Polymorphic objects are larger due to `vptr`.

* Object slicing happens when assigning derived → base by value. Always use pointers/references to preserve polymorphism.


## Polymorphic Objects Stored in Collections
* In C++, when we put derived objects inside a collections of base objects, only the base part is stored. THis is called object slicing.
* TO keep polymorphism, we should store pointers or refernces. (`vector<Base*>`,)(`vector<unique_ptr<Base>>`)

**Case 1: Store by value → ❌ slicing**
```cpp
#include <iostream>
#include <vector>
using namespace std;

class Animal {
public:
    virtual void sound() { cout << "Animal sound\n"; }
};

class Dog : public Animal {
public:
    void sound() override { cout << "Dog barks\n"; }
};

int main() {
    vector<Animal> animals;   // storing objects directly
    animals.push_back(Dog()); // Dog sliced into Animal

    for (auto &a : animals)
        a.sound();
}
```

OUTPUT :
```cpp
Animal sound
```

**Case 2: Store by pointer → ✅ works**
```cpp
#include <iostream>
#include <vector>
using namespace std;

class Animal {
public:
    virtual void sound() { cout << "Animal sound\n"; }
};

class Dog : public Animal {
public:
    void sound() override { cout << "Dog barks\n"; }
};

int main() {
    vector<Animal*> animals;   // store pointers
    animals.push_back(new Dog());

    for (auto a : animals)
        a->sound();
}
```

## `override` keyword in C++

* When a derived class provides a new definition for a virtual functions from the base class, it's called overiding.
* Using the `override` keyword makes the compiler check correctness
* If you mistype or mismatch parameters, the compiler will throw an error instead of silently creating a new functions.

**Example :**
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void sound() { cout << "Animal sound\n"; }
};

class Dog : public Animal {
public:
    void sound() override {   // override ensures this matches a base virtual function
        cout << "Dog barks\n";
    }
};

class Cat : public Animal {
public:
    void sounds() override {   // ❌ typo, compiler error!
        cout << "Cat meows\n";
    }
};

int main() {
    Animal* a = new Dog();
    a->sound();
}
```

```output
Dog barks
```

**Key Point :**
* Without `override`, the typo in `Cat::sounds()` would compile but not override -> bug!
* With `override`, compiler catches it.

`override` = safety net overriding virtual functions.  

## Overloading, Overriding & Hiding in C++

| Concept         | Meaning                                                                                                                                           | Binding               | Example Use Case                               |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------- | ---------------------------------------------- |
| **Overloading** | Same function name, **different parameter list** in the same scope.                                                                               | Compile-time (static) | `add(int, int)` vs `add(double, double)`       |
| **Overriding**  | Derived class **redefines a virtual function** of base class (same signature).                                                                    | Runtime (dynamic)     | `Animal::sound()` overridden in `Dog::sound()` |
| **Hiding**      | Derived class defines a function with the **same name** as base, but not marked `virtual`. It hides the base version (even if parameters differ). | Compile-time          | Avoid accidental use of base class function    |


**Example :**
```cpp
#include <iostream>
using namespace std;

// ---------- Overloading ----------
class Math {
public:
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; } // Overloaded
};

// ---------- Overriding ----------
class Animal {
public:
    virtual void sound() { cout << "Animal sound\n"; }
};

class Dog : public Animal {
public:
    void sound() override { cout << "Dog barks\n"; }
};

// ---------- Hiding ----------
class Base {
public:
    void show() { cout << "Base show\n"; }
};

class Derived : public Base {
public:
    void show(int x) { cout << "Derived show with " << x << "\n"; } // hides Base::show()
};

int main() {
    // Overloading
    Math m;
    cout << "Overloading: " << m.add(2, 3) << ", " << m.add(2.5, 3.5) << endl;

    // Overriding
    Animal* a = new Dog();
    cout << "Overriding: "; a->sound();

    // Hiding
    Derived d;
    cout << "Hiding: "; d.show(10);
    // d.show();  // ❌ error: Base::show() hidden
}
```

```output
Overloading: 5, 6
Overriding: Dog barks
Hiding: Derived show with 10
```

*  Overloading = Same name, different signature (compile-time).

* Overriding = Virtual function redefined (runtime).

* Hiding = Base function shadowed, not overridden.

# Inheritance & Polymorphism at Different Levels

When using inheritance, functions can be called at different levels:
* **Base class reference / pointer :** decides whether polymorphism works (via `virtual`).
* **Object of base vs arrived :** slicing may occur if stored directly as base object.
* **Overiddden vs. hidden vs. non-virtual:** determines binding (static vs dynamic)

| Case                        | Function Call From | Virtual? | Which Version Runs             |
| --------------------------- | ------------------ | -------- | ------------------------------ |
| Base pointer to Base obj    | Base               | Yes/No   | Base function                  |
| Base pointer to Derived obj | Derived            | Yes      | Derived function               |
| Base pointer to Derived obj | Derived            | No       | Base function (static binding) |
| Derived object directly     | Derived            | N/A      | Derived function               |

**Example :**
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void normalFunc() { cout << "Base normal function\n"; }
    virtual void virtualFunc() { cout << "Base virtual function\n"; }
};

class Derived : public Base {
public:
    void normalFunc() { cout << "Derived normal function\n"; }
    void virtualFunc() override { cout << "Derived virtual function\n"; }
};

int main() {
    Base b;
    Derived d;
    Base* ptr;   // base class pointer

    cout << "--- Base object ---\n";
    b.normalFunc();     // Base
    b.virtualFunc();    // Base

    cout << "\n--- Derived object ---\n";
    d.normalFunc();     // Derived
    d.virtualFunc();    // Derived

    cout << "\n--- Base pointer to Base object ---\n";
    ptr = &b;
    ptr->normalFunc();  // Base (static)
    ptr->virtualFunc(); // Base (dynamic but still base obj)

    cout << "\n--- Base pointer to Derived object ---\n";
    ptr = &d;
    ptr->normalFunc();  // Base (static binding)
    ptr->virtualFunc(); // Derived (dynamic binding)
}
```

```output
--- Base object ---
Base normal function
Base virtual function

--- Derived object ---
Derived normal function
Derived virtual function

--- Base pointer to Base object ---
Base normal function
Base virtual function

--- Base pointer to Derived object ---
Base normal function
Derived virtual function
```

* normalFunc() (non-virtual) always uses Base version if accessed through Base*.

* virtualFunc() (virtual) resolves at runtime → Derived version runs if Base* points to Derived.

## Polymorphism and Static Members in Inheritance
* Static members belong to the class itself, not to objects.
* They do not participate in polymorphism -> always resolved at compile time (static binding).
* Even if declared in base and re-declared in derived, they don't behave llike `virtual` functions.

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    static void show() {
        cout << "Base static function\n";
    }
};

class Derived : public Base {
public:
    static void show() {
        cout << "Derived static function\n";
    }
};

int main() {
    Base b;
    Derived d;
    Base* ptr = &d;

    cout << "--- Direct Calls ---\n";
    b.show();   // Base
    d.show();   // Derived

    cout << "\n--- Using Base pointer ---\n";
    ptr->show();  // Base (static binding, not polymorphic)

    cout << "\n--- Class name access ---\n";
    Base::show();    // Base
    Derived::show(); // Derived
}
```

```output
--- Direct Calls ---
Base static function
Derived static function

--- Using Base pointer ---
Base static function

--- Class name access ---
Base static function
Derived static function
```

* Static functions don’t use virtual mechanism.

* Call is resolved at compile-time → depends on type of pointer or class name, not object.

## `final` in C++

* `final` is a C++11 keyword.
* It prevents:
  1. A class from being inherited.
  2. A virtual function from being overriden further.

**Example 1: Final class**
```cpp
#include <iostream>
using namespace std;

class Base final {   // cannot be inherited
public:
    void show() {
        cout << "Base class function\n";
    }
};

// ❌ Error: Derived cannot inherit from Base
// class Derived : public Base {};

int main() {
    Base b;
    b.show();
}
```

```output
Base class function
```

```cpp
#include <iostream>
using namespace std;

class A {
public:
    virtual void display() final {  // cannot be overridden
        cout << "A's display\n";
    }
};

class B : public A {
public:
    // ❌ Error: cannot override final function
    // void display() override { cout << "B's display\n"; }
};

int main() {
    A a;
    a.display();  // A's display
}
```

```output
A's = display
```

* `final` after class -> stops inheritance.
* `final` after function -> stops overriden.


## Virtual Functions with Default Arguments
* Virtual functions use dynamic binding for function calls.

* But default arguments are bound statically (decided at compile-time).

* So → the function body is chosen at runtime (dynamic), but the default value is chosen from the base class declaration.

**Example :**
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void show(int x = 10) {   // default argument = 10
        cout << "Base show: x = " << x << endl;
    }
};

class Derived : public Base {
public:
    void show(int x = 20) override {  // default argument = 20
        cout << "Derived show: x = " << x << endl;
    }
};

int main() {
    Base* ptr = new Derived();

    ptr->show();   // function chosen at runtime (Derived)
                   // default arg chosen at compile time (Base)
}
```

```output
Derived show: x = 10
```

**Why?**

* Function is virtual, so at runtime → Derived::show runs.

* Default argument is not virtual, so compiler uses Base’s default = 10.


**Summary :**
* Function body → chosen at runtime (polymorphism).

* Default arguments → chosen at compile-time (based on pointer/reference type).

## Virtual Destructors
* Destructors are special functions that clean up when an object goes out of scope or is deleted.

* **Without virtual destructor:**

  * If you delete a derived object using a base class pointer, only the base destructor runs → resource leak.

* **With virtual destructor:**

  * Both base and derived destructors run correctly (in order).

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() { cout << "Base constructor\n"; }
    virtual ~Base() {   // virtual destructor
        cout << "Base destructor\n";
    }
};

class Derived : public Base {
public:
    Derived() { cout << "Derived constructor\n"; }
    ~Derived() {
        cout << "Derived destructor\n";
    }
};

int main() {
    Base* obj = new Derived();
    delete obj;   // deleting via base pointer
}
```

OUTPUT :
```cpp
Base constructor
Derived constructor
Derived destructor
Base destructor
```

* Destructors should be virtual in base classes when using polymorphism.

* Ensures proper cleanup of derived class objects.

* If not virtual → only base destructor runs, which may cause resource leaks.


## `dynamic_cast<>()`
* `dynamic` is used for safe type casting in polymorphic classes (classes with it at least one virtual functions)
* It checks at runtime whether a cast is valid.
* Works with pointers and references.
  * if the cast is invalid :
    * For pointer -> returns `nullptr`.
    * For refernces -> throws `bad_cast` exception.

**Example (pointer cast)**
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void show() { cout << "Base\n"; }
};

class Derived : public Base {
public:
    void show() override { cout << "Derived\n"; }
};

class Another : public Base {};

int main() {
    Base* b1 = new Derived;
    Base* b2 = new Another;

    Derived* d1 = dynamic_cast<Derived*>(b1);   // valid
    if (d1) d1->show(); // prints Derived

    Derived* d2 = dynamic_cast<Derived*>(b2);   // invalid
    if (d2) d2->show();
    else cout << "Cast failed\n";

    delete b1;
    delete b2;
}
```

```output
Derived
Cast failed
```

**Example 2 (References Cast)**
```cpp
#include <iostream>
#include <typeinfo>
using namespace std;

class Base { public: virtual ~Base(){} };
class Derived : public Base {};

int main() {
    Base b;
    try {
        Derived& d = dynamic_cast<Derived&>(b);  // invalid
    } catch (bad_cast& e) {
        cout << "Exception: " << e.what() << endl;
    }
}
```

```output
Exception: std::bad_cast
```

**Uses Cases :**
* When you don’t know at runtime what type of object a Base* is pointing to.

* Useful in downcasting (Base* → Derived*).

* Safer than static_cast, since it checks validity at runtime.

## Calling Virtual Functions in Constructors & Destructors

* When inside a constructor or destructor, C++ does not use dynamic binding.

* It always calls the version of the function from the current class, not the derived one.

* **Reason:** The derived object is not fully constructed (or already destroyed), so calling its virtual functions would be unsafe.

**Example :**
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() { cout << "Base constructor\n"; show(); } // virtual call inside constructor
    virtual void show() { cout << "Base show\n"; }
    virtual ~Base() { cout << "Base destructor\n"; show(); } // virtual call inside destructor
};

class Derived : public Base {
public:
    Derived() { cout << "Derived constructor\n"; }
    void show() override { cout << "Derived show\n"; }
    ~Derived() { cout << "Derived destructor\n"; }
};

int main() {
    Derived d;
}
```

OUTPUT :
```output
Base constructor
Base show
Derived constructor
Derived destructor
Base destructor
Base show
```

**Explanation**

* In constructor of Base, `show()` is called → but only `Base::show()` runs, not `Derived::show()`.

* In destructor of Base, same thing → only `Base::show()` runs.

* Virtual mechanism is disabled inside constructors/destructors to avoid calling functions on incomplete objects.

## Pure Virtual Functions & Abstract Classes
* A pure vurtual function is declared using `= 0` 
* A class with at least one pure virtual funcitons becomes an abstract class.
* YOu cannot create objects of abstract clases.
* They are used to define an interference (only what functions must, exist, not how).
* Derived classes must override the pure virtual function to become conccrete

```cpp
#include <iostream>
using namespace std;

// Abstract class (interface-like)
class Shape {
public:
    virtual void draw() = 0; // pure virtual
};

class Circle : public Shape {
public:
    void draw() override {
        cout << "Drawing Circle\n";
    }
};

class Square : public Shape {
public:
    void draw() override {
        cout << "Drawing Square\n";
    }
};

int main() {
    // Shape s;  ❌ Error: cannot create object of abstract class

    Shape* s1 = new Circle();
    Shape* s2 = new Square();

    s1->draw();   // Drawing Circle
    s2->draw();   // Drawing Square

    delete s1;
    delete s2;
}
```

```output
Drawing Circle
Drawing Square
```

* Abstract classes let you enforce a contract (all shapes must have `draw()`),

* but each derived class decides how to implement it.

## Abstract Classes & Interference in C++
* An abstract class = a class with at least one pure virtual function
* Pure virtual functions -> declared like this:
```cpp
virtual void func() = 0;
```

* Abstract classes cannot be instantiated (no objects).
* They are used interfaces -> only define what should be done, not how.
* Derived classes must provide implementation.

**Example : Interface**
```cpp
#include <iostream>
using namespace std;

// Abstract class as an Interface
class Animal {
public:
    virtual void sound() = 0;  // Pure virtual function
    virtual void move() = 0;   // Another pure virtual function
    virtual ~Animal() {}
};

// Derived class Dog
class Dog : public Animal {
public:
    void sound() override { cout << "Dog barks\n"; }
    void move() override { cout << "Dog runs\n"; }
};

// Derived class Bird
class Bird : public Animal {
public:
    void sound() override { cout << "Bird chirps\n"; }
    void move() override { cout << "Bird flies\n"; }
};

int main() {
    Animal* a1 = new Dog();
    Animal* a2 = new Bird();

    a1->sound();  // Dog barks
    a1->move();   // Dog runs

    a2->sound();  // Bird chirps
    a2->move();   // Bird flies

    delete a1;
    delete a2;
}
```

OUTPUT :
```cpp
Dog barks
Dog runs
Bird chirps
Bird flies
```

1. Abstract class = "blueprint" or interface for derived classes.

2. Ensures all derived classes implement required functions.

3. Useful in large projects where you want a common API.


