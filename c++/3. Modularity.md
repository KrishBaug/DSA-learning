# Modularity

A *Declaration* specifies all that's needed to use a function or a type

1. A C++ program has many parts like functions and classes, which work together.
2. Declaration = telling what something is and how to use it.
   Ex: `double sqrt(double);` means there is a function named `sqrt` that takes a number and returns a number.
   It does not say how the function works

3. Defintion =  the actual code that does the work
   double sqrt(double d){
    // code to calculate the square root
   }

4. Classes have declaration and definition too:
   Example declaration:
```cpp
class Vector {
public:
  Vector(int s);
  double& operator[](int i);
  int size();
private:
  double* elem;
  int sz;
};

```
This tells you VEctor van be created with a size `s`, you can get elemments with [], and find its size.
Example definition:
```cpp
Vector::Vector(int s) : elem{new double[s]}, sz{s} { }
double& Vector::operator[](int i) { return elem[i]; }
int Vector::size() { return sz; }

```
THis is the real code that builds the Vector, returns elements, and gives the size.

## Seperate Compiltation
**Purpose:**
* Enables program parts (functions, types) to be developed, compiiled seperately.
* Code using a part sees only declarations (interface), not fully implementation.

**Two ways to do seperate compilations:**
* Header files(.h)
  * Place declarations in header file.
  * Use `#include` to copy declarations where needed.
* Modules(C++20)
  * Define modules in seperate files
  * Compile independently
  * Import explicitly exported declarations.
  
### Header files (Traditional method)
```cpp
class Vector {
    public:
        Vector(int s);
        double& operator[](int i);
        int size();
    private:
        double* elem;
        int sz;
}
```
* Users include header:
```cpp
#include "Vector.h"
```
* Implementation  in `.cpp` files also include same header:

```cpp
#include "Vector.h"
Vector::Vector(int s) : elem{new double[s]}, sz{s} { }
double& Vector::operator[](int i) { return elem[i]; }
int Vector::size() { return sz; }
```
Benefits of seperate compilations:
* Multiple source files can be compiled independently (faster builds)
* Clear interface vs implementation seperations

Drawback of hheader files and `#include':
* **Compilation**: header included in many files cause repeated compilation.
* **Order Dependencies**: Inclusion, order affects meaning, can cause subtle bugs. 
* **Inconsistencies**: Multiple definitions/ declarations accross files cam crash program.
* **Transistivity of the code bloat**: headers including many other header increase dependencies.

### Module
* A language supported way to express modularity
* Groups code into a unit with explicitly exported interface
* Replaces header files + `#include` for better modularity.
  
```cpp
export module Vector;  // Define module "Vector"

export class Vector {
public:
    Vector(int s);
    double& operator[](int i);
    int size();
private:
    double* elem;
    int sz;
};

Vector::Vector(int s) : elem{new double[s]}, sz{s} { }

double& Vector::operator[](int i) { return elem[i]; }

int Vector::size() { return sz; }

export bool operator==(const Vector& v1, const Vector& v2) {
    if (v1.size() != v2.size()) return false;
    for (int i = 0; i < v1.size(); ++i)
        if (v1[i] != v2[i]) return false;
    return true;
}
```

* `export` marks what is visible outside the module.
* Members & functions not exported are hidden (implementation details).

Using a module:
```cpp
import Vector;  // import module interface

#include <cmath>   // old-style include for math functions (mixing allowed)

double sqrt_sum(Vector& v) {
    double sum = 0;
    for (int i = 0; i != v.size(); ++i)
        sum += std::sqrt(v[i]);
    return sum;
}

```
* `import` replaces `#include` for modular code.
* Mixing old and new includes/imports possible during transition.

**Advantages over headers:**
* Module compiled once only, reused across translation units.
* Import order does not affect meaning.
* Imports are not transistive.
* Improves compile time and code hygiene dramatically.

**Real world impact:**
* Example:
  `import std;` compiles ~10x faster than `include <iostream>`.
  Because modules export only interfaces, not full code.

**Example of a module exporting a template function:**
```cpp
export module vector_printer;
import std;

export
template<typename T>
void print(std::vector<T>& v) {
    cout << "{\n";
    for (const T& val : v)
        std::cout << " " << val << '\n';
    cout << '}';
}

```

### Namespaces
**Purposes:**
* Group related declarations together.
* Avoid name clashes between different parts or libraries

```cpp
namespace My_code {
    class complex { /* ... */ };
    complex sqrt(complex);
    int main();
}

int My_code::main() {
    complex z{1,2};
    auto z2 = sqrt(z);
    std::cout << '{' << z2.real() << ',' << z2.imag() << "}\n";
}

int main() {
    return My_code::main();
}

```
* `My_code` namespace groups complex number related code
* Prevents clashes with `std` (standard library) complex types
* `main(`in global namespace calls `My_code::main()`

**Accessing names in namespace:**
* Use qualified name:
  `std::cout`, `My_code::main()`
* Avoids confusion between same names in different namespaces.

**Using declarations:**
Bring a single nname into current scope for easier access.

```cpp
using std::swap;  // Now can call swap() directly
swap(x, y);       // Calls std::swap()
other::swap(x,y); // Calls another swap()

```

**Use directives:**
Bring all names from a namespace into current scope:
```cpp
using namespace std;
cout << "Hello\n";  // instead of std::cout

```
* Simplifies code but risks name conflicts
* Best used carefully, often for widely used namespace like `std`.

```cpp
export module vector_printer;
import std;
using namespace std;

export
template<typename T>
void print(vector<T>& v) {
    cout << "{\n";
    for (const T& val : v)
        cout << " " << val << '\n';
    cout << '}';
}

```