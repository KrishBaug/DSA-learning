# Classes

A class in C++ is a user-defined data type that groups data (variables) and functions (methods) together.
* Data members: Store information (like variables inside the class).
* Member functions (methods): define behaviour (what the object can do).

### **Basic Syntax**
```cpp
#include <iostream>
using namespace std;

class Car {
public:   // access specifier
    string brand;   // data member
    int year;

    void display() {   // member function
        cout << "Brand: " << brand << ", Year: " << year << endl;
    }
};

int main() {
    Car myCar;         // create object
    myCar.brand = "Toyota";
    myCar.year = 2020;

    myCar.display();   // call member function
    return 0;
}
```

## Access Specifiers in class

* **Public** : Accesible from anywhere (outside & inside class)
* **Private** : Accessible only inside the class.
* **Protected** : Like private, but accessible in derived in derived classes.

```cpp
#include <iostream>
using namespace std;

class Person {
public:                     // Public section
    string name;

    void introduce() {
        cout << "Hi, I am " << name << ", and I am " << age << " years old." << endl;
    }

protected:                  // Protected section
    string nationality = "Indian";  // Can’t be accessed directly in main(), 
                                    // but subclasses can use it.

private:                    // Private section
    int age;                // Only accessible inside Person

public:                     // Public function to set private data
    void setAge(int a) {
        age = a;            // Allowed (inside the class)
    }
};
 
int main() {
    Person p1;
    p1.name = "Krish";      // ✅ Public → accessible
    p1.setAge(17);          // ✅ Use setter to change private variable
    p1.introduce();         // ✅ Can use method that accesses private data

    // p1.age = 17;         // ❌ Error: 'age' is private
    // cout << p1.nationality; // ❌ Error: 'nationality' is protected
}
```

* Use private to hide sensitive data.

* Use public for interface (functions & safe variables).
* Use protected for inheritance.

## Constructor in C++
* A constructor is a function inside a class.
* Automatically called when an object is created. 
* Has the same name as the class
* NO return type (not even void)

**Types of Constructors**

1. Default Constructor : No parameters.

2. Parameterized Constructor : Accepts parameters.

```cpp
#include <iostream>
using namespace std;

class Student {
private:
    string name;
    int age;

public:
    // Default constructor
    Student() {
        name = "Unknown";
        age = 0;
        cout << "Default constructor called" << endl;
    }

    // Parameterized constructor
    Student(string n, int a) {
        name = n;
        age = a;
        cout << "Parameterized constructor called" << endl;
    }

    void display() {
        cout << "Name: " << name << ", Age: " << age << endl;
    }
};

int main() {
    Student s1;              // Calls default constructor
    s1.display();

    Student s2("Krish", 17); // Calls parameterized constructor
    s2.display();

    return 0;
}
```

* Constructors run automatically when you create an object.

* You can overload constructors (multiple versions with different parameters).

* They help in initializing data members safely.

## Defaulted constructor
What is a Defaulted Constructor?

* If you don’t write any constructor, the compiler automatically creates a default one (that does nothing special).

* You can explicitly ask the compiler to generate one using = default;.

* This is useful when you want a default constructor along with other constructors.

```cpp
#include <iostream>
using namespace std;

class Student {
private:
    string name;
    int age;

public:
    // Explicit default constructor
    Student() = default;

    // Parameterized constructor
    Student(string n, int a) {
        name = n;
        age = a;
    }

    void display() {
        cout << "Name: " << name << ", Age: " << age << endl;
    }
};

int main() {
    Student s1;            // Uses default constructor
    s1.display();          // name and age are empty/uninitialized

    Student s2("Krish", 17);
    s2.display();

    return 0;
}
```

* `= default` tells compiler: “generate the default constructor for me”.

* Useful when:

    * You need both default and parameterized constructors.

    * You want to make your intent clear.

## How to write methods for classes
1. **Inline (Inside the class definition) :**
* Method body written directly in the class.
```cpp
class Student {
public:
    void sayHello() {  // inline
        cout << "Hello!" << endl;
    }
};

simple small functions
```

2. **Outside class (using `::` scope resolution)**
Declare inside class, define outside.
```cpp
class Student {
public:
    void sayHello();  // only declaration
};

// Definition outside
void Student::sayHello() {
    cout << "Hello!" << endl;
}
```
* Good for large projects (keeps header clean)

## Setter and Getter

* **Setter :** function that sets / updates the value of a private / protected data.
* **Getter :** function that returns the value of a priivate / protected data member.

```cpp
#include <iostream>
using namespace std;

class Student {
private:
    string name;
    int age;

public:
    // Setter for name
    void setName(string n) {
        name = n;
    }

    // Getter for name
    string getName() {
        return name;
    }

    // Setter for age (with a check)
    void setAge(int a) {
        if(a > 0)  // simple validation
            age = a;
    }

    // Getter for age
    int getAge() {
        return age;
    }
};

int main() {
    Student s;

    s.setName("Krish");   // using setter
    s.setAge(17);

    cout << "Name: " << s.getName() << endl;
    cout << "Age: " << s.getAge() << endl;

    return 0;
}
```

**Why use them ?**
* Encapsulation → keep variables private, control access.

* Validation → e.g., you can prevent setting negative age.

* Consistency → keeps internal state safe.

### Inline
Inline just means we write the function body inside the class definition.
If we wrote functions outside, it would look like this:

```cpp
class Student {
private:
    string name;
    int age;

public:
    void setName(string n); // declaration only
    string getName();
};
```

define seperately:
```cpp
void Student::setName(string n) { name = n; }
string Student::getName() { return name; }
```

## Classes accross multiple files
Why split classes into files?

* For big projects, keeping everything in main.cpp becomes messy.

* We usually split into:

  * Header file (.h / .hpp) → Class declaration.

  * Source file (.cpp) → Class function definitions.

  * Main file → Uses the class.

**Example :**
* Student.h (header file)
```cpp
#ifndef STUDENT_H
#define STUDENT_H

#include <string>
using namespace std;

class Student {
private:
    string name;
    int age;

public:
    Student(string n, int a);   // Constructor
    void display();             // Function prototype
};

#endif
```

* Student.cpp (implementation file)
```cpp
#include "Student.h"
#include <iostream>
using namespace std;

// Constructor definition
Student::Student(string n, int a) {
    name = n;
    age = a;
}

// Function definition
void Student::display() {
    cout << "Name: " << name << ", Age: " << age << endl;
}
```

* main.cpp
```cpp
#include "Student.h"

int main() {
    Student s("Alex", 20);
    s.display();
    return 0;
}
```

* Compilation 
```bash
g++ main.cpp Student.cpp -o program
./program
```

This makes projects organized and scalable.

# Managing Class Objects Through pointers

Why pointers for objects ?
* Normally, we create objects like:
```cpp
Student s("Alex", 20)
```
* But sometimes we want to create objects dynamically (at runtime, on heap memory) -> then we use pointers.

* Example :
```cpp
#include <iostream>
using namespace std;

class Student {
    string name;
    int age;

public:
    Student(string n, int a) {
        name = n;
        age = a;
    }
    void display() {
        cout << "Name: " << name << ", Age: " << age << endl;
    }
};

int main() {
    // 1. Normal object
    Student s1("Alex", 20);
    s1.display();

    // 2. Object through pointer (on heap)
    Student* s2 = new Student("Bob", 22);
    s2->display();   // use -> instead of . for pointer

    // 3. Delete to free memory
    delete s2;

    return 0;
}
```

* `new` creates object on heap.
* `->` used instead of `.` when accessing through pointers.
* `delete` frees memory (otherwise).

## Destructor
* A special function in a class
* Runs automatically when an object goes out of scope or is deleted 
* Used to release resources (memory, file handles, connections)
* Same name as class but with `~` prefix.
* Takes no arguments and returns nothing.

**Example :**
```cpp
#include <iostream>
using namespace std;

class FileHandler {
public:
    FileHandler() {
        cout << "File opened!" << endl;
    }

    ~FileHandler() {   // destructor
        cout << "File closed!" << endl;
    }
};

int main() {
    FileHandler f1;    // constructor runs here
    cout << "Doing some work..." << endl;
}   // object destroyed → destructor runs here
```

```arduino
File opened!
Doing some work...
File closed!
```

* You don’t call destructors manually → C++ calls them automatically.

* If you create an object with new, you must call delete so destructor runs.

* Very important in RAII (Resource Acquisition Is Initialization) → ensures resources are cleaned properly.

## Constructor & Destructor Call Order

**When do constructors and destructors run?**

1. Constructor → runs when object is created.

2. Destructor → runs when object goes out of scope or is deleted.

3. In case of multiple objects or inheritance, the order matters.

**Example with multiple objects**
```cpp
#include <iostream>
using namespace std;

class Test {
    string name;
public:
    Test(string n) : name(n) {
        cout << "Constructor: " << name << endl;
    }
    ~Test() {
        cout << "Destructor: " << name << endl;
    }
};

int main() {
    Test t1("A");
    Test t2("B");
    cout << "Inside main" << endl;
    return 0;
}
```
**Output :**
```
Constructor: A
Constructor: B
Inside main
Destructor: B
Destructor: A
```

**Observation :**
* constructor run in order of declaration.
* destructor run in reverse order.

**With dynamic allocation**
```cpp
Test* t3 = new Test("C"); // constructor runs
delete t3;                 // destructor runs
```

If you forget delete, destructor won’t run, causing memory leak.

## The `this` Pointer in C++
* Each class member function contains a hidden pointer called this. 
* That pointer contains the address of the current object, for which the method is being executed. This also applies to constructor and destructors.

**Why is it used ?**
1. **Diambiguation :** when function parameter have the same name as data members.
2. **Method chaining :** allows multiple function calls on the same object in one statement.
3. **Access current object :** compare, return, or pass the current object.

```cpp
class Student {
    int age;
public:
    void setAge(int age) {
        this->age = age;  // this->age = object's age, age = parameter
    }
};
```

### chaining using pointer and references
**Chaining** = calling multiple functions on the same object in a single line
* Using references (recommended)
```cpp
class Student {
    int age;
public:
    Student& setAge(int a) { age = a; return *this; }
    Student& grow() { age++; return *this; }
    void display() { cout << age << endl; }
};

int main() {
    Student s;
    s.setAge(17).grow().grow();  // chaining
    s.display(); // 19
}
```

* Using pointers 
```cpp
class Student {
    int age;
public:
    Student* setAge(int a) { age = a; return this; }
    Student* grow() { age++; return this; }
    void display() { cout << age << endl; }
};

int main() {
    Student s;
    s.setAge(17)->grow()->grow();  // pointer chaining
    s.display(); // 19
}

```

**Difference**:
| Aspect      | Reference chaining        | Pointer chaining                         |
| ----------- | ------------------------- | ---------------------------------------- |
| Syntax      | `obj.func1().func2()`     | `obj.func1()->func2()`                   |
| Return type | `ClassName&`              | `ClassName*`                             |
| Usage       | Most common in modern C++ | Only when working with object pointers   |
| Why         | Cleaner, safe, efficient  | Works with dynamically allocated objects |

**When to use chaining**

* When you want compact code like s.setAge(17).grow().grow();

* When you want method calls on the same object without writing s. repeatedly.

* Pointers chaining is mainly used if the object is created dynamically (new Student)

## Size of classes and Structs
**What is it?**

* Size = amount of memory an object occupies.

**Depends on:**

* Data members (int, double, char, etc.)

* Padding/alignment (C++ aligns memory for efficiency)

* Virtual functions (adds vtable pointer)

**Example 1: Simple struct**
```cpp
#include <iostream>
using namespace std;

struct Point {
    int x;
    int y;
};

int main() {
    cout << "Size of Point: " << sizeof(Point) << " bytes" << endl;
}
```

* Each int = 4 bytes

* Size = 8 bytes (usually)

**Example 2: With padding**
```cpp
struct Test {
    char a;   // 1 byte
    int b;    // 4 bytes
};

int main() {
    cout << "Size of Test: " << sizeof(Test) << endl;
}
```

* Output (likely): 8 bytes, not 5

* Why? : Padding added to align int on 4-byte boundary

**Example 3: Class with virtual function**
```cpp
class Base {
    int x;
public:
    virtual void fun() {}
};

int main() {
    cout << "Size of Base: " << sizeof(Base) << endl;
}

```
* Size includes vtable pointer (usually 8 bytes on 64-bit system)

* Total size = int + vptr → 16 bytes

**Key Points**

* sizeof(object) or sizeof(ClassName) gives object size.

* Memory = data members + padding + vtable pointer (if virtual)

* Padding ensures fast access by CPU

* Useful to know for arrays of objects, memory management


### Example
```cpp
struct Complex {
    char  a;   // 1 byte
    double b;  // 8 bytes
    int   c;   // 4 bytes
    short d;  // 2 bytes
};

```

**Step-by-step Calculation (TP):**

1. char a → 1 byte

    * Next member = double (needs 8-byte alignment)

    * Add 7 bytes padding after a.

    * Total so far = 1 + 7 = 8

2. double b → 8 bytes
   * Total = 8 + 8 = 16

   * int c → 4 bytes
   * Total = 16 + 4 = 20

3. short d → 2 bytes
   * Total = 20 + 2 = 22

* Struct alignment rule = round up to multiple of largest member (here 8 for double).

* Nearest multiple of 8 ≥ 22 = 24

* sizeof(Complex) = 24

**Important Points**

* Largest member decides overall alignment.

* Padding happens between members + at the end (tail padding).

* Rearranging members can save memory.

### optimize the struct to reduce padding.
New over previous struct
```cpp
struct ComplexOpt {
    double b;  // 8 bytes
    int   c;   // 4 bytes
    short d;  // 2 bytes
    char  a;   // 1 byte
};
// sizeof = 16

```
Step-by-step Calc:

1. double b → 8 bytes ✅ total = 8

2. int c → 4 bytes ✅ total = 12

3. short d → 2 bytes ✅ total = 14

4. char a → 1 byte → total = 15

4. Round up to nearest multiple of 8 = 16

* Final size = 16 bytes instead of 24

**Takeaway :**
* Always put largest members first → then descending order.

* Saves memory & avoids wasted padding.
