# Classes

A class in C++ is a user-defined data type that groups data (variables) and functions (methods) together.
* Data members: Store information (like variables inside the class).
* Member functions (methods): define behaviour (what the object can do).

### **Basic Syntax**
```cpp
#include <iostream>
using namespace std;

class Car {
public:   // access specifier
    string brand;   // data member
    int year;

    void display() {   // member function
        cout << "Brand: " << brand << ", Year: " << year << endl;
    }
};

int main() {
    Car myCar;         // create object
    myCar.brand = "Toyota";
    myCar.year = 2020;

    myCar.display();   // call member function
    return 0;
}
```

## Access Specifiers in class

* **Public** : Accesible from anywhere (outside & inside class)
* **Private** : Accessible only inside the class.
* **Protected** : Like private, but accessible in derived in derived classes.

```cpp
#include <iostream>
using namespace std;

class Person {
public:                     // Public section
    string name;

    void introduce() {
        cout << "Hi, I am " << name << ", and I am " << age << " years old." << endl;
    }

protected:                  // Protected section
    string nationality = "Indian";  // Can’t be accessed directly in main(), 
                                    // but subclasses can use it.

private:                    // Private section
    int age;                // Only accessible inside Person

public:                     // Public function to set private data
    void setAge(int a) {
        age = a;            // Allowed (inside the class)
    }
};
 
int main() {
    Person p1;
    p1.name = "Krish";      // ✅ Public → accessible
    p1.setAge(17);          // ✅ Use setter to change private variable
    p1.introduce();         // ✅ Can use method that accesses private data

    // p1.age = 17;         // ❌ Error: 'age' is private
    // cout << p1.nationality; // ❌ Error: 'nationality' is protected
}
```

* Use private to hide sensitive data.

* Use public for interface (functions & safe variables).
* Use protected for inheritance.

## Constructor in C++
* A constructor is a function inside a class.
* Automatically called when an object is created. 
* Has the same name as the class
* NO return type (not even void)

**Types of Constructors**

1. Default Constructor : No parameters.

2. Parameterized Constructor : Accepts parameters.

```cpp
#include <iostream>
using namespace std;

class Student {
private:
    string name;
    int age;

public:
    // Default constructor
    Student() {
        name = "Unknown";
        age = 0;
        cout << "Default constructor called" << endl;
    }

    // Parameterized constructor
    Student(string n, int a) {
        name = n;
        age = a;
        cout << "Parameterized constructor called" << endl;
    }

    void display() {
        cout << "Name: " << name << ", Age: " << age << endl;
    }
};

int main() {
    Student s1;              // Calls default constructor
    s1.display();

    Student s2("Krish", 17); // Calls parameterized constructor
    s2.display();

    return 0;
}
```

* Constructors run automatically when you create an object.

* You can overload constructors (multiple versions with different parameters).

* They help in initializing data members safely.

## Defaulted constructor
What is a Defaulted Constructor?

* If you don’t write any constructor, the compiler automatically creates a default one (that does nothing special).

* You can explicitly ask the compiler to generate one using = default;.

* This is useful when you want a default constructor along with other constructors.

```cpp
#include <iostream>
using namespace std;

class Student {
private:
    string name;
    int age;

public:
    // Explicit default constructor
    Student() = default;

    // Parameterized constructor
    Student(string n, int a) {
        name = n;
        age = a;
    }

    void display() {
        cout << "Name: " << name << ", Age: " << age << endl;
    }
};

int main() {
    Student s1;            // Uses default constructor
    s1.display();          // name and age are empty/uninitialized

    Student s2("Krish", 17);
    s2.display();

    return 0;
}
```

* `= default` tells compiler: “generate the default constructor for me”.

* Useful when:

    * You need both default and parameterized constructors.

    * You want to make your intent clear.

## How to write methods for classes
1. **Inline (Inside the class definition) :**
* Method body written directly in the class.
```cpp
class Student {
public:
    void sayHello() {  // inline
        cout << "Hello!" << endl;
    }
};

simple small functions
```

2. **Outside class (using `::` scope resolution)**
Declare inside class, define outside.
```cpp
class Student {
public:
    void sayHello();  // only declaration
};

// Definition outside
void Student::sayHello() {
    cout << "Hello!" << endl;
}
```
* Good for large projects (keeps header clean)

## Setter and Getter

* **Setter :** function that sets / updates the value of a private / protected data.
* **Getter :** function that returns the value of a priivate / protected data member.

```cpp
#include <iostream>
using namespace std;

class Student {
private:
    string name;
    int age;

public:
    // Setter for name
    void setName(string n) {
        name = n;
    }

    // Getter for name
    string getName() {
        return name;
    }

    // Setter for age (with a check)
    void setAge(int a) {
        if(a > 0)  // simple validation
            age = a;
    }

    // Getter for age
    int getAge() {
        return age;
    }
};

int main() {
    Student s;

    s.setName("Krish");   // using setter
    s.setAge(17);

    cout << "Name: " << s.getName() << endl;
    cout << "Age: " << s.getAge() << endl;

    return 0;
}
```

**Why use them ?**
* Encapsulation → keep variables private, control access.

* Validation → e.g., you can prevent setting negative age.

* Consistency → keeps internal state safe.

### Inline
Inline just means we write the function body inside the class definition.
If we wrote functions outside, it would look like this:

```cpp
class Student {
private:
    string name;
    int age;

public:
    void setName(string n); // declaration only
    string getName();
};
```

define seperately:
```cpp
void Student::setName(string n) { name = n; }
string Student::getName() { return name; }
```

## Classes accross multiple files
Why split classes into files?

* For big projects, keeping everything in main.cpp becomes messy.

* We usually split into:

  * Header file (.h / .hpp) → Class declaration.

  * Source file (.cpp) → Class function definitions.

  * Main file → Uses the class.

**Example :**
* Student.h (header file)
```cpp
#ifndef STUDENT_H
#define STUDENT_H

#include <string>
using namespace std;

class Student {
private:
    string name;
    int age;

public:
    Student(string n, int a);   // Constructor
    void display();             // Function prototype
};

#endif
```

* Student.cpp (implementation file)
```cpp
#include "Student.h"
#include <iostream>
using namespace std;

// Constructor definition
Student::Student(string n, int a) {
    name = n;
    age = a;
}

// Function definition
void Student::display() {
    cout << "Name: " << name << ", Age: " << age << endl;
}
```

* main.cpp
```cpp
#include "Student.h"

int main() {
    Student s("Alex", 20);
    s.display();
    return 0;
}
```

* Compilation 
```bash
g++ main.cpp Student.cpp -o program
./program
```

This makes projects organized and scalable.

# Managing Class Objects Through pointers

Why pointers for objects ?
* Normally, we create objects like:
```cpp
Student s("Alex", 20)
```
* But sometimes we want to create objects dynamically (at runtime, on heap memory) -> then we use pointers.

* Example :
```cpp
#include <iostream>
using namespace std;

class Student {
    string name;
    int age;

public:
    Student(string n, int a) {
        name = n;
        age = a;
    }
    void display() {
        cout << "Name: " << name << ", Age: " << age << endl;
    }
};

int main() {
    // 1. Normal object
    Student s1("Alex", 20);
    s1.display();

    // 2. Object through pointer (on heap)
    Student* s2 = new Student("Bob", 22);
    s2->display();   // use -> instead of . for pointer

    // 3. Delete to free memory
    delete s2;

    return 0;
}
```

* `new` creates object on heap.
* `->` used instead of `.` when accessing through pointers.
* `delete` frees memory (otherwise).

## Destructor
* A special function in a class
* Runs automatically when an object goes out of scope or is deleted 
* Used to release resources (memory, file handles, connections)
* Same name as class but with `~` prefix.
* Takes no arguments and returns nothing.

**Example :**
```cpp
#include <iostream>
using namespace std;

class FileHandler {
public:
    FileHandler() {
        cout << "File opened!" << endl;
    }

    ~FileHandler() {   // destructor
        cout << "File closed!" << endl;
    }
};

int main() {
    FileHandler f1;    // constructor runs here
    cout << "Doing some work..." << endl;
}   // object destroyed → destructor runs here
```

```arduino
File opened!
Doing some work...
File closed!
```

* You don’t call destructors manually → C++ calls them automatically.

* If you create an object with new, you must call delete so destructor runs.

* Very important in RAII (Resource Acquisition Is Initialization) → ensures resources are cleaned properly.

## Constructor & Destructor Call Order

**When do constructors and destructors run?**

1. Constructor → runs when object is created.

2. Destructor → runs when object goes out of scope or is deleted.

3. In case of multiple objects or inheritance, the order matters.

**Example with multiple objects**
```cpp
#include <iostream>
using namespace std;

class Test {
    string name;
public:
    Test(string n) : name(n) {
        cout << "Constructor: " << name << endl;
    }
    ~Test() {
        cout << "Destructor: " << name << endl;
    }
};

int main() {
    Test t1("A");
    Test t2("B");
    cout << "Inside main" << endl;
    return 0;
}
```
**Output :**
```
Constructor: A
Constructor: B
Inside main
Destructor: B
Destructor: A
```

**Observation :**
* constructor run in order of declaration.
* destructor run in reverse order.

**With dynamic allocation**
```cpp
Test* t3 = new Test("C"); // constructor runs
delete t3;                 // destructor runs
```

If you forget delete, destructor won’t run, causing memory leak.

