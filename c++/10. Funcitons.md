# Functions

# One Definition Rule
* Definitions can't show up more then once in entire program or Translation units.
* C++ rule that says every entity (variable, function, class, template, etc.) must have exactly one definition in the entire program.
* You may have multiple declarations, but only one definition.

```cpp
// Declaration (tells compiler it exists)
extern int x;  

// Definition (allocates storage)
int x = 5;

```

* One definiton rule : context
  1. Free standing variables
  2. Functions
  3. Clases (have to show up )
  4. Class member functions
  5. Class static member variables

## Functions
A reusable piece of code that can take a number of optional inputs and produce some desirable output.

```cpp
return_type function_name(parameter_list) {
    // function body
    return value; // optional if return_type is void
}
```

how to call a function
```cpp
function_name(inputs)
```

## function declaration and definition
* Sometimes it's more flexible to split the function into it's header and body and the code for each in different places.
* when writing libraries the people reading the code dont want to know how the code works but just want to know the name of function and use it.
For Example,
```cpp
#include <iostream>

int max(int a, int b); // Function declaration , prototype
                        // Signature doesn't include return type
int min(int a, int b);

int inc_mult( int a, int b);

int main(){

    int x {5};
    int y{12};

    int result = min(x,y);
    std::cout << "min : " << result << std::endl;

    result =inc_mult(x,y);
    std::cout << "result : " << result << std::endl;

    return 0;
}

//Function definition. Shows up after main 
int max(int a, int b){
    if(a > b)
        return a;
    else
        return b;
}


//Function definition. Shows up after main 
int min(int a, int b){
    if(a < b)
        return a;
    else
        return b;
}

int inc_mult( int a, int b){
    return ( (++a)*(++b));
}
```

## Function accross Multiple files
1. Preprocessing:
   * Handles `#include`, `#define`, macros, conditional compilation.
   * Replaces headers inline -> each `.cpp` + headers becomes a single translation unit (pure C++ code, no preprocessors directives)
2. Compilation : 
   * Each translation unit is compiled into assembly.
   * Builds a symbol table with local + external references 
   * external functions/ variables = marked as unresolvable symbols.
3. Assembly:
   * Converts assembly into object code(`.o`)
   * `.o` contains machine code + relocation info + symbol table.
4. Linking:
   * Collects all `.o` files + libraries
   * Resolves unresolved symbols across files.
   * Fixes addresses (relocation)
   * Produces a single executable (e.g. `a.out`)

**Multi-file Function Model :**
1. Header file(.h):
   * Contains declarations (function protypes)
   * Tells the compiler "this function exists somewhere".
```c
#ifndef
#define
int add(int a, int b);
#endif
```

2. Source file(`.cpp`):
   * Contains definition (actual function body)
```cpp
// math_utils.cpp
#include "math_utils.h"
int add(int a, int b){return a + b;}
```

3. Main file (`.cpp`):
   * include the header and uses the function.
```cpp
//main.cpp
#include <iostream>
#include "math_utils.h"

int main(){
  std::cout<<add(3,4);
}
```

4. Compilation:
   * Compile all `.cpp` files together.
```bash
g++ main.cpp math_utils.cpp -o program
```

## Pass by Value
* When you pass an argument to function by value, the function gets a copy of the variable's value.
* **Effect** : Changes inside the functions do not affect the original variable.

```cpp
#include <iostream>
using namespace std;

void change(int x) {
    x = 50; // modifies only local copy
}

int main() {
    int a = 10;
    change(a);
    cout << a;  // Output: 10 (unchanged)
}
```

## Pass by Pointer (C++)
* The function receives a pointer (memory adddress) of the variables, not a copy of its value.
* **Effect**: Changes inside the function affect the original variable, because both point to the same memory location.

```cpp
#include <iostream>
using namespace std;

void change(int* x) {
    *x = 50; // dereference pointer and modify original
}

int main() {
    int a = 10;
    change(&a);   // pass address of 'a'
    cout << a;    // Output: 50 (changed)
}
```

## Pass by Reference (C++)
* The function receives an alias (reference) to the original variable.
* **Effect :** Changes inside the function directly affect the caller's variable (no copy made.)
```cpp
#include <iostream>
using namespace std;

void change(int& x) {   // reference parameter
    x = 100;            // directly changes caller's variable
}

int main() {
    int a = 10;
    change(a);          // pass by reference
    cout << a;          // Output: 100
}
```

## Pass by Reference Vs Pass by Pointers
| Feature                    | Pass by Reference (`int&`)                    | Pass by Pointer (`int*`)                       |
| -------------------------- | --------------------------------------------- | ---------------------------------------------- |
| **Syntax**                 | `void f(int& x)`                              | `void f(int* x)`                               |
| **Call style**             | `f(a);`                                       | `f(&a);`                                       |
| **Access inside function** | Use `x` directly                              | Must use `*x` (dereference)                    |
| **Null safety**            | Cannot be null                                | Can be `nullptr`                               |
| **Re-seating**             | Cannot rebind reference                       | Pointer can point elsewhere                    |
| **Ease of use**            | Cleaner, simpler                              | More flexible but verbose                      |
| **Common usage**           | Safer parameter passing, operator overloading | Low-level manipulation, arrays, dynamic memory |





