# Function Template 
A funciton template lets you write a function once and use it with different data types without rewriting the code.
Think of it as a blueprint for a function.

* **Functional Overloading :**
You write seperate versions for each type:
```cpp
int add(int a, int b) {
    return a + b;
}

double add(double a, double b) {
    return a + b;
}

string add(string a, string b) {
    return a + b;
}
```
This works fine… but if you want float, long, char, etc. you must keep adding overloads manually.

* **But in functional Template :**
You write one generic version, and the compiler genrates overloads for you:

```cpp
template <typename T>
T add(T a, T b) {
    return a + b;
}
```

The compiler will create:

* int add(int,int)

* double add(double,double)

* string add(string,string) …automatically when you call them.

**Difference :** 
* Overloading -> good when each type needs different logic.
* Template -> good when the logic is identical accross types.

## Template Type deduction 
When you call a function, the compiler deduces the type automatically from the arguments.
```cpp
#include <iostream>
using namespace std;

template <typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    cout << add(3, 5) << endl;       // T deduced as int
    cout << add(3.2, 5.8) << endl;   // T deduced as double
}
```

## Explicitly Template Arguments
Sometimes, deduction is not possible, or want to force a specific type. You can explicitly pass the type inside `< >`.

```cpp
#include <iostream>
using namespace std;

template <typename T>
T square(T x) {
    return x * x;
}

int main() {
    cout << square<int>(5.5) << endl;   // Explicitly force int, result = 25
    cout << square<double>(5.5) << endl; // Explicitly force double, result = 30.25
}
```

Even though `5.5` is `double`, by writing `<int>` you override deduction.

## Mixed Case
Sometimes, the compiler cannot deduce the type because of mismatched arguments:
```cpp
template <typename T>
T multiply(T a, T b) {
    return a * b;
}

int main() {
    // cout << multiply(3, 4.5); ❌ Error: int vs double mismatch
    cout << multiply<double>(3, 4.5); // ✅ Works by forcing T = double
}
```

## Template Parameter by Reference
### Normal Template Parameter

```cpp
template <typename T>
void printValue(T x) {
    cout << x << endl;
}
```
* Here `T` is passed by value -> a copy is made.
* Works fine for the small types (`int`, `double`), but copying large objects (like vectors, strings) is expensive.

### Template Parameter by Reference
```cpp
template <typename T>
void printRef(T& x) {   // Pass by reference
    cout << x << endl;
}
```
* `T&` means reference to T.
* No copy is made -> faster for large objects.
* Also allows modifying the arguments inside the function.

### Const Reference:
```cpp
template <typename T>
void printConstRef(const T& x) {
    cout << x << endl;
}
```
* Most common in practice.
* Accepts values, temporaries, literals.
* Safe & efficient because it avoids copies but doesn't allow modification.

### Universal reference (T&&
```cpp
template <typename T>
void printUniversal(T&& x) {
    cout << x << endl;
}
```
* Special cases: T&& in a template means "accept both l_values and r_values."
* Useful for perfect forwarding.

## Declaration and Definition
```cpp
#include <iostream>
using namespace std;

// Template function declaration
template <typename T>
T add(T a, T b);  // Declaration only (no body yet)

int main() {
    cout << add(3, 5) << endl;  // Error if definition is not provided later
    return 0;
}

// Template function definition (later)
template <typename T>
T add(T a, T b) {
    return a + b;
}
```

## Template Specialization
Sometimes a general template doesn't work efficiently for a particular type.
So you can specialize the template for that specific type.

1. General Template 
```cpp
#include <iostream>
using namespace std;

template <typename T>
class Printer {
public:
    void print(T value) {
        cout << "General template: " << value << endl;
    }
};
```

2. When specialized for Strings:
```cpp
// Specialization
template <>
class Printer<string> {
public:
    void print(string value) {
        cout << "Specialized for string: " << value << endl;
    }
};
```

**Usage :**
```cpp
int main() {
    Printer<int> p1;    
    p1.print(42);        // Uses general template

    Printer<string> p2;  
    p2.print("Hello");   // Uses specialized template
}
```

**Same but for functions**
```cpp
template <typename T>
void show(T x) {
    cout << "General: " << x << endl;
}

// Specialization for double
template <>
void show<double>(double x) {
    cout << "Specialized for double: " << x << endl;
}
```

* General template handles most types.

* Specialization overrides it for a specific type.

* Helps optimize performance or handle exceptions.


